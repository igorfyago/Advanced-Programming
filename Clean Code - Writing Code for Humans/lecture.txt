Introduction
Hi and welcome to Clean Code: Writing Code for Humans. I'm Cory House with Pluralsight. In this course I'm excited to discuss how to develop code in a style that's easy to write and more importantly easy for our fellow developers to read, maintain, and understand. Two quotes from well-known developers sum up the inspiration for this course. First, Donald Knuth the Author of The Art of Computer Programming Series said, Programming is the art of telling another human what one wants the computer to do. As developers we often feel like our job is done as soon as the software reacts as expected. I love this quote because it emphasizes the importance of coding in a style that other programmers can understand and consume. Martin Fowler, Author of Refactoring and Improving the Design of Existing Code and many other excellent books on programming said, Any fool can write code that a computer can understand. Good programmers write code that humans can understand. This course is about writing code with the finite capacity of the human brain and mind. So let's get started. This course is for the good kind of lazy programmer, anyone who wants to make their job easier. And as we'll learn when writing Clean Code you not only make your job easier, you improve the quality of life for everyone on your development team. Code examples throughout are presented in C#, but developers working in other C-like languages such as JavaScript, Java, Perl, PHP, et cetera should be able to follow right along no problem. Also, since most of the principles are universal and have little to do with specific programming languages developers in other languages like Python and Ruby will get a lot from the course as well. Finally, although it's certainly not a requirement we will discuss classes and methods so some points do assume general familiarity with Object-Oriented Programming.

Why should I care?
There is a pile of great reasons for learning Clean Coding techniques. Let's roll through a few. If you've never asked yourself if your code is dirty then it likely is. Those who wrist Clean Code are able to convey many concrete activities, patterns, and techniques that they use to keep their code clean. If you can't justify the cleanliness of your code there's likely plenty of opportunity for improvement. Developers often pride themselves with their ability to solve problems. However, it's important to remember that writing code is easy, but Reading is hard. So, if you write code that you're barely able to follow as you write you'll likely find you're unable to comprehend it at all later. Professional developers write so much code that after a few weeks of separation most of the details of the design and structure fall out of memory and it's often like looking at the project with a completely fresh perspective. Not being able to understand your own code a few weeks later can be a really depressing experience. Trust me, I've been there. Third, Technical debt is depressing. Writing sloppy code injects technical debt into our projects. And while this debt can be useful when carefully considered in context excessive technical debit is depressing and drives talent away from the organization. When the easy things become hard developers start voting with their feet and go elsewhere. The three qualities of a good programmer are laziness, impatience, and hubris. Laziness can actually be a positive attribute in the right context. As I stumbled through writing dirty code in my early years I learned the hard way that taking the time to write Clean Code really pays off because it's easier to work with later. Good developers strive to be the good kind of lazy and this laziness is based on putting extra care into the code upfront so that it's not so hard to work with later. When under pressure it's tempting to cut corners and ignore best practices, however, as Uncle Bob Martin reminds us in his book Clean Code we do not have time to be sloppy. Being sloppy ultimately slows us down in the long term due to increased frequency of bugs and the long-term costs of maintenance. History has shown that it's unlikely you'll find time to clean it up later. When a boss is given a choice between speed and quality they'll almost always choose speed. Now, developers on the other hand would prefer to be able to take their time often and do it right. Now, the beauty of this course is you really don't have anything to give up to be able to gain speed in your development process. Clean Code practices will get you to the point that you are both clean and fast in your development. Finally, you don't want to be verb. Everyone knows the previous coworker whose name has become a verb to describe dirty code. "Oh man, this code has been Jimmy'd. " We want our coworkers to recommend and hire us for future positions right? So, being known for writing Clean Code is a great way to assure that your coworkers recommend you and look forward to working with both you and your code in the future.

The Foundation
In this course we're building a foundation for being a more professional developer. This begins by writing higher quality code. Clean Code means a lot of things to different people, but our goal here is to build upon a clear, approachable, near universal set of principles for writing code in a style that's readable and maintainable. As you'll see this approach is heavily inspired by writing principles you're already familiar with. Writing Clean Code, as we'll define in this course, is a useful foundation for many other popular software development practices such as the SOLID principles that Robert C. Martin, more popularly known as Uncle Bob, outlined for object oriented programers. Implementing Clean Code Principles is useful whether you choose to write automated tests for your code or not. And many will justifiably argue that no code is clean without test coverage. Some, such as Michael Feathers, Author of Working Effectively with Legacy Code goes so far as to define Legacy Code as any code without tests. Now, Automated Testing is indeed an important topic that's related to Clean Code, but that's not the focus of this particular course. That said, Clean Code Principles will indeed help you write code that's more modular and thus easier to test. If you're more interested in learning about testing check out Julie Lermans's excellent introductory course called Automated Testing for Fraidy Cats Like Me, highly recommended. Now, once you understand Clean Code Principles and Automated Testing you're fully equipped to professionally Refactor Code. Steve Smith is currently creating a Pluralsight course on Refactoring that's yet to be published. Finally with these four foundational skills you can enhance your design and Refactoring skills with Design Patterns, Test Driven Development, and Domain Driven Design. This is obviously not an exhaustive list of skills, but all of these techniques and practices build on and benefit from the core skill of writing Clean Code.

We are Authors
Hey, want to impress your mom? Well, tell her you're an author. The definition of an author most certainly includes developers. An author is a writer of a book, article or text. More specifically, an author is someone who practices writing as a profession. Hey, we write all day. An author is one who writes or constructs an electronic document system. Electronic system? Wow, sounds like software to me. Finally, an author is an originator or creator as of a theory or plan. Developers often design plans before writing using UML, user stories, mockup tools or simply white boards. So, it's clear and definitive we are authors. Yet, as developers it's easy to forget that each line of code that we write is likely to be read 10 or more times by humans during its lifetime. These humans are our fellow coworkers. They're busy fixing bugs and adding new features. Great authors are known for writing books that tell a clear compelling story. They use tools like Chapters, Headings and Paragraphs to clearly organize their thoughts and painlessly guide the reader. As we're going to learn there are many parallels for developers who work in a rather comparable system, but with different jargon of Namespaces, Classes, and Methods. Consider a chapter in a book. A well-named chapter summarizes the high level topic to the reader. And a well-chosen namespace serves the same role, although it's even more critical in software development since multiple authors are regularly choosing where to add new code. Well-chosen namespaces help guide developers to be responsible organized authors who place code in the right bucket. In the same way Headings in a chapter define a more specific idea to discuss and are broken down by paragraphs. If the heading is too general or insufficiently descriptive it's more difficult for the reader to comprehend the authors intent. If a paragraph is too long or disjointed the reader will become fatigued and confused about the mission. Classes with low cohesion and long meandering methods suffer the exact same fate. Readers struggle to understand in intent of poorly named classes and as we'll soon explore further there are concrete reasons to become fatigued by reading long methods.

Conventions
I'm a big believer that one of the best ways to learn is through examples. So, throughout the course we'll be comparing what we'll call Dirty Code, which is something to avoid with Clean Code, something that you should strive for. This should help clearly convey the improvement and the principles being discussed. Second, Clean Code is focused on the human reader. So, this may sound crazy, but talking to yourself can be a really beneficial way to evaluate your code. Since the human reader has to reason about the code by reading it, we're going to compare selected code snippets by reading the results out loud to emphasize how much more natural the clean versions read. As we'll see, Verbalizing as you read exposes redundancy and confusing sections and thus helps you focus your efforts on being more expressive.

Resources
Early on in my career I learned the importance of Clean Code the hard way. I made mistakes and struggled with the structure of my code. Then, I read these guys. Let's review three books that have inspired this course. First, Steve McConnell and Code Complete remains the highest voted book that a developer should read on Stack Overflow and for good reason. It offers a huge breadth of knowledge on software construction. Second, Robert C. Martin or Uncle Bob as he is better known, is the father of Clean Code. Uncle Bob helped establish many of the principles we'll discuss in this course. He's an inspiration to me and his book is an entertaining and practical read on how to write Clean Code that I highly recommend as a followup to this course. Finally while this book isn't focused direly on Clean Code, The Pragmatic Programmer covers a wide variety of best practices for being a professional developer and we'll cover some unique principles from The Pragmatic Programmer that apply directly to our goal of keeping our code clean and readable.

Principles
Three Core Principles
Hi I'm Cory House and in this module we're going to talk about three core principles for writing Clean Code. Okay, pay attention because throughout this course you're going to hear regular references to these three core principles for writing Clean Code. First, Clean Code involves using the right tool. As software developers we have so many tools at our disposal that sometimes the hardest part is simply selecting the right tool for the job. We have to recognize that every technology has its place. Throughout this course we'll discuss how to select data structures, when certain technologies become evil, and outline some places where you can avoid writing any code at all. Secondly, we're going to talk about the signal to noise ratio of our code. In Science and Engineering the term signal to noise ratio compares the level of a desired signal to the level of background noise. A quality audio amplifier produces minimal noise as it boosts sound, which allows the listener to enjoy the music without creating distracting background hiss. In the same way Clean Code ostomizes for signal and strives to remove any noise so that the reader can easily read the logic and understand the intent. We'll walk through many techniques for increasing signal and eliminating noise from our code. Once we've selected the right tool and optimized our signal and removed noise our lofty goal is to write code in such a clear and expressive style that no documentation is needed at all. Code that reaches this level is self-documenting. Steve McConnell, Author of Code Complete, points out that the main contributor to code level documentation isn't comments, but good programming style. We'll walk through many techniques for replacing comments and other developer oriented documentation with expressive code. Now let's review these three principles in more detail.

The Right Tool for The Job
Okay, be honest. You've probably worked with somebody that has this sort of mind set. Sure many developers have a few favorite technologies and there's nothing wrong with specializing and striving for expertise with a given tool. But, make sure this line doesn't apply to you. Developers who've become too fixated on a given tool, pattern or paradigm are cursed to misuse it. Like this. Yes, sadly this is me hauling furniture. Clearly my grocery getter is the wrong tool for this job. Now, here's the funny thing. I may walk around with pride and expect you to compliment me on being a creative problem solver. I took something that was clearly not going to fit and I hacked in a solution. As developers we do this all the time. In fact, I could go on and I could brag about how I put padding on my armrest to keep the heavy box from scarring up the interior and I closed the sunroof the perfect amount to provide extra support on the box so that it doesn't fly out when I drive down the highway. And hey, the rain hardly leaked in through the opening in the sunroof. Now, at this point in real life you'd be holding back an epic eye-roll because this work is nothing to be proud of. It's hard to even sit in the driver's seat and work with the steering wheel with the box sitting there and I can't even use the rearview mirror. My mistake, quite clearly, is I began by selecting the wrong tool. All too often we are proud of the wrong things. We're proud of creativity and hackery when a more elegant solution might exist. So, let's review some principles for selecting the right tool for the job to avoid embarrassing mistakes like this.

Boundaries Matter: Stay Native
When selecting tools the risk for picking the wrong tool for the job exists at the Boundaries. Let's consider some common technologies for building web applications today. Each technology has a specific purpose. HTML provides semantic markup for our content. CSS separates our styling from our markup. JavaScript provides behavior. And the server side language that we choose manages the business logic. Finally, SQL is useful for relational database, data access, and manipulation. And here's the thing, it's the boundaries and interactions between these technologies that get people in trouble. First, it's tempting to put HTML in a JavaScript string so that you can dynamically inject HTML onto the page. But all markup should ideally be written as HTML. JavaScript is the wrong tool for storing markup. And on the flipside it's tempting to put JavaScript directly in your HTML, but this mixes concerns by injecting behavior directly into your markup and it eliminates the opportunity for caching and reuse. When possible JavaScript belongs in. js files and HTML belongs in. html files. Second, generally relational databases should contain raw normalized data so that it can be leverage for a variety of purposes. Thus, storing HTML in the database or injecting HTML in query results as strings is problematic. It binds the presentation and data storage together, which makes reuse really difficult. It's a very similar story with the HTML CSS interaction. It's tempting to place styles inline in HTML, but this mixes our semantic markup with style. These are separate concerns, which eliminates the opportunity for caching and reuse of CSS. It's easy to create highly Dynamic SQL in a server side language like C# using strings to generate SQL statements, but stored procedures and ORMs often provide a safer and more elegant approach to generating Dynamic SQL. Finally, this is the most common tool misuse that I see, using a server side language to generate Dynamic JavaScript. In most cases JavaScript can remain in a JS file and JSON can be returned from the server to provide Dynamism. Let's now take a look at a specific example of using the wrong tool for the job to generate Dynamic JavaScript. Here we have an example application that is delivering the Google Analytics JavaScript code dynamically. As you can see the Google Analytics ID is being injected into the middle of this script. So, this is a snippet of code that would sit in C# for instance within a code behind. And the idea was that we put it within a string so that we could inject the one Dynamic piece here, which is the Google Analytics ID. Now, let's take a look at a cleaner example. Here we can see that the JavaScript code is now sitting within a file called GoogleAnalytics. js. And we can also notice right away that we have the benefit of code coloring, which makes the code much easier to read and imagine if I made a typo along the way I'd know immediately. If I typo up to and type document and miss the u, I wouldn't know this until I ran the code, but my IDE will help me out as I write within a JS file using the style below. Now, you're probably wondering, where is this WebSiteSetup. GoogleAnalyticsKey defined? Well, it's defined in the header of the document. Here we can see a snippet of JavaScript that defines this data. And the beauty of all this is this is all just native JavaScript. To inject this Dynamic data into the header you can use your languages JSON serializer to serialize some native object, in this case I'm using C#, so I can use C# JSON serializer to serialize this out into the header so that I get this Dynamic piece of data that's useful for my JS file down below. And there's a lot of benefits to doing so. By Staying Native our code is Cached. It's downloaded once by the browser and then that JS file isn't requested again because it already has those resources. When you put JS within your HTML it's downloaded again and again on each page request. It's also Code colored. If you looked at the old version in a string it was all Code colored as the one C# string, which makes very difficult to read and maintain. Closely related to this, you lose Syntax checking when you try to write one language within a string. There's no way for it to check whether you've made a typo so it becomes very difficult to maintain. Separate files for each language are easier to maintain and understand because each file handles a single focused role. And we wouldn't have any easy way to Reuse this code. This is also more performant because it avoids string parsing on every single request. Instead we serve up the file once and then browsers in a lot of cases don't request it again for a long period of time. Finally, we can minify and obfuscate our JavaScript code in this case because it's a separate file. That wouldn't be easily done if we were doing string parsing and building this together dynamically. Of course, the importance of Staying Native isn't at all specific to JavaScript. There's a variety of opportunities to find yourself struggling with strings when there's a less painful alternative that involves Staying Native. The bottom line is avoid using one language to write another language or format via strings. Creation of these formats dynamically is a solved problem in most popular languages these days. So, be sure to Leverage Libraries to generate such formats. A good rule of thumb is to strive for one language per file. Generating any of these items via strings requires the reader to understand the interactions of two technologies simultaneously. And as we just saw this totally breaks tooling support. So, if you notice you have two languages and one file, think twice about how you could eliminate one by solving the problem in a different and more elegant way.

Potential Evil
Every technology has its niche and its limits. The trick to choosing the right tool for the job involves considering when the technologies you know best become evil. Consider some examples. Linq-to-SQL is a very powerful and loved technology for data access used by many C# and VB. NET programmers. However, it becomes ungainly when used for Massive Queries and has a very obscure syntac for simple Outer joins. Flash and Silverlight are powerful tools for creating rich experiences, but many other capabilities can be matched with native alternatives and when those native alternatives are an option that completely covers your problem domain then they should really be considered. JavaScript is great for implementing rich interactions within a browser, but it cannot be relied up as the Sole method of Validation and it's also a poor choice for imbedding critical Proprietary Logic since it's exposed to the client for anyone to potentially read or alter.

Signal to Noise Ratio
To enjoy good music Signal to Noise Ratio is a key factor. If there's too much noise it's hard to understand the lyrics. The more subtle pieces of the music are lost and the whole experience becomes less enjoyable and more taxing. In the same way, code with a high Signal to Noise Ratio is easier to understand. In this course we'll define Signal as any logic that follows the TED rule. TED stands for Terse. Your code should not be excessively wordy. Expressive, it's clear what the code is trying to do. And finally, the code should do one thing. It should have a clear responsibility and should do that one thing well. But in competition with signal there's always noise. So, throughout this course we'll walk through items that add noise to our code and discuss techniques for increasing the Signal and reducing Noise. This is just a sampling of some common items that add noise to our code and thereby reduce readability and hinder maintenance. When we read code our brain is the compiler. A 1956 study published in Psychological Review found humans can hold no more than 7 items in short-term memory at once plus or minus 2. Thus having more than 7 items in scope at one time makes it difficult for the reader to comprehend the code. Since we have such a limited short-term memory increasing the signal to noise ratio in our code is critical for assuring the reader isn't wasting memory on information that isn't currently relevant or worse, overwhelmed with more information than they can process at one. The rule of 7 has a big impact on how we should write code including the number of parameters we should accept for a method, the number of methods in a class, and the number of local variables we keep in scope at a single point in time. Methods with more than 7 parameters are certainly difficult to reason about. To assure that humans can read and reason about our code we must strive to break it down into bite size pieces that we can hold in our head. Second, the signal naturally decays over time and noise naturally grows over time. So, we must refactor regularly as we write and maintain our code to avoid creating a huge mess that needs to be replaced rather than maintained. This kitchen didn't become a disaster overnight. Day by day no thought was given to organization. No time was taken to clean up before starting the next task. Trash wasn't thrown away. In a condition like this it's very difficult to do even simple tasks like cook bacon and eggs. In the same way if we don't regularly strive to write Clean Code we may find ourselves here. This is a massive SQL query from the daily WTF. It's called the query of despair. Just like the kitchen this query didn't become an intimidating mess in a single sitting. It's the product of ongoing changes without concern for writing Clean Code and no refactoring was done along the way. The computer has no problem parsing this, but our finite brains overflow attempting to parse something so complex.

DRY Principle
Arguably the most important principle in programing is don't repeat yourself or as the book, The Pragmatic Programmer called it, the DRY Principle. Clean Code honors the DRY Principle by stating each piece of knowledge or logic once and only once. Relational database schema designers normalize their database in an effort to assure each piece of data is defined in a single place. This assures that the database operates efficiently and consistently and eases maintenance. This principle holds true in code as well. Copy and paste is often a sign of a design problem and can easily be eliminated by creating a reusable function or adding a parameter to an existing function to make it more flexible. Now, there's a number of issues with duplicated code. If code is copy and pasted into multiple locations it decreases the signal to noise ratio. It's the equivalent of repeating the same paragraph twice in a book. Authors get their point across once and make references to previous chapters. Methods and classes serve the same purpose in object oriented programming. Clean Coders strive to avoid copy and paste since every line of code is a liability. It's code we have to maintain. It's code we have to read. It's code we have to debug. Bill Gates said, measuring programming progress by lines of code is like measuring air craft building progress by weight. So true. Much like an airplane our goal is to stay light. This means minimizing the lines of code in our code base. And multiple studies have found that fewer lines of code are correlated with fewer bugs. This duplication also creates a maintenance problem. When a bug is fixed in one spot it may persist elsewhere. When a feature is added in one place other copy and pasted locations are likely to be overlooked. And keep in mind that many pieces of duplication aren't even immediately obvious, but if you squint your eyes at this code you can see that it has a repetitious shape. And this infers that there's an opportunity for simplification. Keep an eye out for shapes and patterns as you code to sniff out subtle cases of redundancy.

Self-documenting Code
Programing style as documentation is all about writing code in such an expressive and clear style that the authors intent is obvious. So obvious that new developers joining the team can easily navigate and read the code to get up to speed. This is a key concern as outlined in a study by Fjelstad & Hamlen in 1979, which found Understanding the original programmer's intent is the most difficult problem. Any maintenance programmer can attest to the fact that often the hardest part of the job is figuring out what the original programmer meant to do. Self-documenting code strives to do four core things. First, express intent clearly so that readers understand exactly what the programmer was trying to accomplish. Second, layers of abstraction should be used so that the problem domain can be considered and walked through at different levels of detail. Third, formatting in a friendly and consistent manner will optimize the reading experience. And finally, favoring code over comments when possible will assure that the code is as expressive as it can be without relying on comments to explain away unnecessary ambiguity. Self-documenting code can reduce and ideally eliminate the need for out-of-band documentation such as Javadoc, Wikis, et cetera, by clearly expressing desired behavior within code instead.

Summary
In summary, Clean Code begins with picking the right tool. You have to watch out for boundaries between technologies that can trip you up. And you need to strive to maximize the signal-to-noise of your code. To do so utilize the TED principle. Your code should be Terse, Expressive, and Do one thing. And make sure you also honor the DRY principle and don't repeat yourself. Finally, have a goal of writing self-documenting code. Don't rely on external documentation and long comments to be able to explain what you're doing. Make your intent clear within code. Also rely on layers of abstraction so that your readers can understand what you're trying to accomplish at various levels of detail.

Naming
Introduction
Hi I'm Cory House and this is Clean Code: Writing Code for Humans. In this module we're going to discuss Naming and why it matters. So, what's in a name? Well, we're about to find out. Here's our plan. We're going to discuss why Naming is so critical and learn some principles for selecting good Class names and some names to avoid. We'll learn how to avoid surprising people with nasty function side-effects and we'll wrap up with some principles for selecting good variable names. So, let's get started.

Naming Matters
Variable Name selection has a huge impact on the readability of our code. This code snippet is simplistic enough that you can likely determine what it does, but without well-chosen variable names it's completely unclear if the code does what the author intended. Remember, understanding the programmers intent is the biggest problem so we must strive to be crystal clear about what we meant to do. Imagine reading book with random one letter abbreviations throughout. P was very angry with G for insulting her M. G kicked P in the A. He slept on the C. It reads a bit like a bad game of mad libs. Now, can you sort out the gist of the story by using the context around poorly chosen names? Sure. But it's taxing and it adds unnecessary confusion. The situation is even worse when programmers use misleading names that actively mask intent. Sure, the computer does not care, but professional developers must think long and hard about variable parameter Method and Class names to assure that their desires are clearly conveyed to the reader. Note, how much easier it is to read this Clean version. The only change that's been made is better variable names. Let's compare reading them like a sentence in a book. Loop through list of P, add each P to T, and return. This is a simple problem, but it sure sounds cryptic. It sounds more like a math class than it does any kind of spoken word. Let's compare that to, loop through list of prices, add each price to total, and return. That's what going on at the bottom, I'm just reading off using the variable names that have been provided. Now note, as we'll discuss in a later module there's a clear opportunity to further simplify this Clean example using the Sum Extension Method in C#, but this example clearly displays an improvement by simply selecting more descriptive names.

Classes
Alright, pay attention because this is key. Well-named Classes are critical for assuring that your application remains maintainable over time. Why? Well, I've seen plenty of times that poor Name Classes become a clear magnet for the lazy. How often do you come in on a Monday in a lousy mood, not really feeling like doing your job, and you need this new feature, but you don't really want to think about where it goes and whether it warrants creating a new Class or being composed within an existing Class. Well, when your project has poorly named Classes like these examples they are a magnet for lazy developers. It's easier to just throw your code in one of these spots than it is to think about where it belongs. These magnet Classes quickly grow to thousands of lines of code and become very difficult to understand and maintain. Nobody really understand what their purpose is and what the consequences are when you instantiate one of these massive Classes. So, in contrast let's look at some Cleaner examples. But note, that depending on your project these examples may still be to general or high level. A well-designed Class should have a single responsibility and its name should help reflect that. Given single responsibility is a tricky judgement call, but it's certainly helpful to regularly ask yourself if the Class is doing too much. Now, here's a few specific Guidelines for naming Classes well. First, good Class names are nouns, not verbs. When you instantiate a Class your creating a thing. You should be able to reason about creating an instance of that thing. Two, the name should be as specific as possible. Keep in mind that specific names lead to smaller and more cohesive Classes. Now, what is a cohesive Class? Well, in a cohesive Class its instance variables are regularly used by many of the Methods within that Class. If a few of the instance variables are only used by a small number of the Methods in that Class, then that Class has low cohesion. It's a sign that it's doing too many things, that there are some instance variables that just aren't used by a large portion of the Class. So, that can be a sign that it's time to refactor out to some separate Classes. So, keep your names specific and if they aren't specific that should be a sign to you that something is going wrong and the design is headed in the wrong direction. The name should also help lead the design toward Single Responsibility. You can imagine that the ProductRepository Class knows how to query the database to get products, but it certainly should not know how to send product emails. Yes, it's generally about products, but you would not expect a logic about sending emails to sit within that Class. The name alone is specific enough that it's unlikely anyone would be tempted to put such an unrelated piece of logic within that Class. Finally, avoid lame and generic suffixes that add no value. A Class storing business logic about products should likely be called Product and not Product Manager or Product Info. If you're wondering about the quality of the name you've selected ask yourself, is an instance of this logical? An instance of Product is quite logical. An instance of Produce Manager or Product Info? That's a little more confusing and might be a sign that you are selecting the wrong name for the Class.

Methods
Remember in school when you'd get assigned long chapters of boring reading? Well, lousy Method Names put a very similar burden on your fellow programmers. Now, that may sound a bit odd, but here's why. Poor Method Names require the reader to read the whole Class before understanding what it does. Look at these examples of poor Method Names. Without reading the code you literally have zero idea what logic is inside. None. You know nothing about the Class if these are the Method Names. Now, you'll also notice that the. NET WebForm Page Life Cycle Methods are listed under Dirty as well. Many frameworks offer pre-named magical Methods like this that get called automatically by convention. But always keep in mind that these Methods are by definition poorly named Methods because all they do is tell you when they are called not what sits inside. By reading the names on these Methods you know nothing about what's going on. Now, you obviously can't go renaming them because that's baked into the framework, but what you can do is only place Method Calls inside. This gives the reader a quick high-level view of what you're trying to accomplish at that point. Now remember, the bottom line when naming Methods is to select a name so descriptive that the reader doesn't have to read the Method to know what it does. The good examples on the right fit this description. There's no need to read the body of these Methods if the description doesn't sound like what you're looking for. We'll talk more about the implications in the Functions Module, but it's very clear, as you look at these, you really don't have to branch them out. GetRegisteredUsers, we can pretty well assume what's inside. IsValidSubmission, ImportDocument, these are self-explanatory names. Now, we will also talk about some, some risks that can go on if people don't honor these names, but assuming that the programmers chose a name that was descriptive of the logic you can save yourself a lot of reading when you're hunting down a specific bug.

Rubber Ducking
Now, Naming should be easy when you honor the Single Responsibility Principle. If your Class or Method are doing one thing it should be easy to describe what the code is doing. But, if you've been coding for a while I'm sure you've had the experience where you've been stumped and had to ask a coworker for help and then halfway through your explanation the solution just strikes you. By verbalizing, you exercised a different part of your brain. That's how you figured it out. So, in the same way if you're having a hard time naming a Method or a Class it often helps to verbalize. Explain what the Class does out loud. And if you don't have a coworker that wants to listen just keep a rubber duck on your deks. If there's no one around who cares to listen explain it to the rubber duck. This sounds silly, but it really does help. Also, pay attention to how broad your description is. Particularly when struggling to name a Method. Ask yourself, am I describing one thing or a set of separate concerns that should potentially reside in separate Classes or separate Methods.

Warning Signs
When Naming Methods, keep an eye out for Warning Signs. If you find yourself using the words And, Or, If, within your Method Name it's a sure sign you're trying to do more than one thing. Common examples include save an email, load and copy, calculate and display, process or deny. If you name the Method to describe everything inside and need to use these words it's a sign you need to create two Methods, not one.

Side Effects
A well-structured Name Method shouldn't surprise consumers with unexpected side effects. For example, a Method called CheckPassword shouldn't log the user out. And ValidateSubmission shouldn't save. When I ask for getting a user I'm not going to expect that to create their session and charging a credit card most certainly should not send emails. Those are separate concerns and when I call that one Method based on its name I'm not going to expect those items on the right to happen. So, make sure that your Methods don't lie to your readers. Otherwise people have to read through every line and make sure that it does exactly what it says it does. We want to be able to trust the contract that you are exposing through the Method Names that you select.

Abbreviations
Hey, remember the 80s? Well, it's not the 80s anymore. So, abbreviations within your code just don't make a lot of sense. Back in the 80s storage was quite limited and expensive. These days storage is cheap and IDEs are robust. We can select long descriptive names and IntelliSense saves us the time required to retype them, we just strike Tab and magic happens and the rest of the text appears. See the problem with abbreviations is few words have a consistent and unambiguous abbreviation in the first place. Imagine reading a book or article filled with cryptic abbreviations. If the author never expounded on these short terms it would make for a seriously frustrating read. Since there's no standard, abbreviations are just to be avoided. Also keep in mind that we talk about our code. And often we read it silently in our heads. Awkwardly abbreviated names hinder discussing the code. Imagine that we have a Class called Register User. Well, if instead we call it RegUsr or RegistUser or RegisUser or RegisterUsr, none of these flow off the tongue. It makes it more difficult for us to read the code and more difficult for us to have a conversation with our colleagues when issues arise. Go ahead and put in the full name and let your IDE make it easy on you. We don't have to type out all these characters anymore and a little bit of extra storage won't hurt anything.

Booleans
Naming Booleans well seems to trip up many developers. The key rule is well-named Booleans should sound like they're asking a true/false question. Naming a Boolean well helps your code read like spoken word. Let's look at some Dirty examples first to show what I mean. Open sounds like a command not a question. Same story with start. Status is ambiguous and awkward since a status of true or false makes little sense. Instead, let's look at some Clean examples that are clearly storing the answer to a true or false question. Is it open? Is it done? Is it active? Conditionals that use Clean Boolean names read very naturally. Let's look at how awkward it is to read the conditional with a poorly chosen Boolean variable name. If login versus if loggedIn. What does a true login mean? If loggedIn is true has a clear meaning. And that's the key. It should be answering a true, asking a true/false question.

Symmetry
Sometimes we deal with opposites in our code. And when we do it's important that we select variable names that have symmetry. They should be clearly opposites. Here are some examples of poorly chosen pairs, on/disabled, quick/slow, locked/open, slow and max. Now, these are all generally related, but they're not clear opposites, which makes them confusing to work with together. So, lets look at how we can make these Clean. On works with off, fast and slow, lock and unlock, min and max. It's even easier for me to read quickly to you on the slide. When you have these opposites to work with in your code make sure that they are clearly opposites. A lot of words have obvious choices on the other side and it will make it easier for people to read and reason about your code.

Summary
So, in this module we learned that you really need to strive for specific Class names. It will help keep your code maintainable and avoid attracting lazy programmers through magnet Classes. We also learned that the name should say it all on a Method. You shouldn't have to read the Method to understand what it does. And it's really important that you watch for nasty side-effects in your function. Somebody should be able to read the name of the function and trust that it's only going to do what is described in that name. That it doesn't do something totally unrelated and surprise people. We learned that Boolean should sound truthy and falsy. They should be asking a specific question that answers either true or false. And finally, when you're struggling with a name feel free to verbalize to a friendâ€¦or to a duck.

Conditionals
Introduction
Hi, I'm Cory House, and in this module on clean code, we'll talk about conditionals. Conditionals provide the exciting plot twists in our code. Imagine you're having a leisurely morning at work, reading a coworker's code. It seems simple, and it's headed in a predictable straight line, but then, bam. You hit a fork in the road, and a conditional gives you the choice of two or more paths. These forks in the road are a critical decision that are worthy of our best efforts at cleanliness and clarity. In this module, we'll hash out how to handle these twists and turns while keeping the reader's best interest in mind. So now we're going to review four simple principles to consider when writing conditionals. First, good conditionals clearly convey intent. Just as in life, it's not enough to nearly understand that we're going right versus left at a fork. It really helps to understand why we made the decision to go in a given direction in the first place. Yet sadly, if developers made road signs, many would be about as helpful as this. Sure, we can see there's a choice between directions, but it's unclear where each road goes and how I would choose between my options. The wording is cryptic and it's just not helpful. Understanding the original programmer's intent is the most difficult problem. Second, we need to be sure to use the right tool for the job. There are many ways to implement conditionals, and as we discussed earlier, selecting the right tool is foundational to writing clean code. With so many ways to send code in a new direction, it's important to think about the reader when selecting an approach. Well-written conditionals offer bite-size logic that our finite minds can easily comprehend at once. We'll review methods to tame long, complicated conditionals into clear, simple statements. And finally, although it might sound crazy, sometimes code is not the answer at all. We'll look at some areas where a conditional could be completely removed altogether. So let's dive in.

Boolean Comparisons
Booleans are a simple concept that many developers don't leverage in the cleanest way. Booleans are an obvious choice when there's a true/false decision to handle. However, it's common for programmers to explicitly compare Booleans against true and false, as you see here. This is totally unnecessary, and it actually just adds noise to the conditional in most cases. Note how the clean version reads like English. Which would you say in real life? If loggedIn equals true, or if loggedIn?

Boolean Assignments
I love Chipotle burritos and this conditional summarizes my feelings. But there's a problem with this conditional. Remember that one of our primary goals when writing clean code is to increase the signal to noise, and to increase the signal to noise, Booleans should be assigned implicitly as well. Now, on the left, we can see that each Boolean is being explicitly assigned to the value true or false. This is unnecessary as you can see in this clean version. Now, there's a number of clear advantages to this more implicit style of assignment on the right. First, take note of how many lines each solution requires. Remember, it's easier to read bite-size pieces of code. And the more signal we can see on the screen at once, the better. Second, in the dirty example, the variable has to be initialized separately from its use within the if and else below, another line on the screen just wasted. Third, there's also a greater risk for mistakes since the variable has to be repeated on three separate lines in the dirty version. Finally, notice again the theme that the clean version reads a lot like spoken word. Let's read each piece of code aloud and see how they compare. I'll start with the clean version. I'm going to Chipotle for lunch if the cashInWallet is greater than 6. Now the dirty version. If the cash in my wallet is greater than 6, I'm going to Chipotle for lunch. Otherwise, I'm not going to Chipotle for lunch. If I talked like that in real life, you'd probably look at me funny for being redundant. It's just awkward. Dirty code spoken aloud often sounds overly wordy and strange in real life too. So, go ahead. Talk to yourself. See how your code devaluates.

Positive Conditionals
Please, do everyone a favor and don't be anti-negative. See, the brain reasons better about positive conditionals than negative ones. And if I want you to keep working, it's easier for you to understand me saying, keep working, than if I say, don't stop working. The negative request creates a lurch in your mind. So, writing negative conditionals increases the cognitive load and reduces readability. So, let me restate this title more clearly. Use positive conditionals. Nice and simple. Now, I'm sure you'll agree that this dirty example is confusing and requires careful thought to comprehend the implication and intent. Again, let's look at the clean example for a contrast. Notice how this reads like the spoken word. It is trivial to understand. Hopefully, no one would ever ask you if you're not is not logged in. That just makes my head hurt. Now, negative conditionals are often a sign of programming by accident. You can imagine the developer was coding along and the code didn't operate as expected. So then he threw an exclamation point in the conditional to negate the Boolean and well, seems to work now. Job is done. Now, if you end up with a negative conditional, strive to refactor the conditional to make a positive rather than a negative test. Trust me. Your readers will thank you.

Ternary Elegance
Here we have a simple example of determining a registration fee based on whether the registrant is a speaker. Now, you might be thinking this is a pretty clean and easy to read example, and for this simple code snippet, I tend to agree. But there's still clear room for improvement because the signal to noise can be significantly increased by utilizing the ternary operator instead. This approach has many of the same benefits as the implicit Boolean assignment that we just discussed. First, it requires far fewer lines and doesn't require repeating the variable that's being assigned. Note how the ternary operator only requires a single reference to the registrationFee variable. The other version makes three separate references, including requiring a dedicated line to initialize the registrationFee variable. That's three different opportunities for a typo and three different references the reader must read. Remember, if the reader isn't interested in what is getting set to the registrationFee variable, then it's trivial to pass by the one liner on the right. However, with the structure on the left, it's ten lines of code to pass over, and it's more work to parse what's going on and whether it's relevant to my goal as a reader. Now, due to misuse, the ternary operator has gotten a bad rap from some who have found it difficult to understand. But when used properly in situations like this, it's actually a real contributor to clean code. The ternary operator offers a very elegant and terse syntax. So, the bottom line is the beauty of the ternary operator and the implicit Boolean assignment that we just reviewed is that they both honor the DRY principle. DRY stands for don't repeat yourself. See the nice thing is you don't have to repeat the variable that you're setting. Now note that you'll have to refactor to a traditional if else if more things need to happen based on a speaker situation. However, clean coders must also remember the term YAGNE. YAGNE stands for, you ain't going to need it. We should not introduce more complexity in our code just because we think we might need it in the future. Go ahead and add the additional complexity when it's truly necessary. And also, like any tool, the ternary can be abused. You should avoid using multiple ternary operators in a single conditional because it hurts readability. Don't chain them together, but in this sort of instance, it helps somebody read our code more quickly.

Stringly Typed
If you work in a strongly typed language, such as C#, VB. net, or Java, you know that strongly typed language offers you the luxury of compiler safety. If you typo a reference, the application will not compile. However, that does not keep developers from using the wrong tool for conditional logic. Strings are a handy Swiss army knife, but using a string in this way is not one of them. Instead, you can leverage an enum to make a strongly typed check for the employee type. There's a variety of benefits to this approach. First, strongly typed means that there's no way to make a typo. If you make a typo the application just will not compile. You cannot run it. So, if I typed manger here instead of manager I'd know immediately, I'd get a squiggly within my IDE. There'd be no way for me to move forward, which is a big win compared to the string up here. If I had typed that, it would fail slowly. I would run the application and then find that there were odd behavior. Who knows at what point it would be obvious that that was the line that I had fat-fingered and typed in the wrong information. Secondly, you end up with Intellisensesupport when you, stay strongly typed. Intellisense helps us finish our sentences, so the IDE pops down, gives you context, you don't have to type as much to get all this done. So although this is more characters here, it's no more work. I will type the em hit tab and then it would fill in employee type and then I would have a list of potential options here. So, it's just a more luxurious experience. It also helps document the potential states. So the employee type has a certain finite number of options here and manager is one of those and I can see those different options and it helps me reason better about the code as I'm learning a new code base. You can't do that with these strings. I'd have to go hunt around and try to find all the places that employee type was referenced, and see whether I could get a feel for all the potential values. Finally, it's searchable. Imagine that you have an application that's working with manager data. That's a big problem because if I search for the word manager, I'm going to find this line and I'm going to find it listed all over the place. Potentially in comments and all these, other areas that are completely unrelated to me just trying to figure out how often I'm looking for a given employee type. And out here using an enum, I can easily hunt for all the places that this enum is referenced. My ID will just help me out, and it is definitive when it does so, as opposed to a string search, where, especially if there was some typos in some places, they just wouldn't show up. So, there's a lot of benefits to being strongly typed, if your language does support it.

Magic Numbers
So can you imagine reading a book where each character's emotion was referred to simply by a number code? It would be infuriating and mentally taxing. Why? Well, numbers by themselves without context don't convey any meaning or intent. Sally went to the number 12 dealer to buy a number 19 number 515. What does that mean? It doesn't convey much information, does it? I'm forced to go hunt around for the meaning behind these magic numbers. This seems quite obvious when we read it in a book, but developers often make this mistake in code. So, here's an example of a very simple conditional. We're just checking if age is over 21. Now, the problem is we have no idea why 21 is significant. To figure this out, we'd have to read between the lines and by reading the function in hopes of determining exactly why the developer typed 21 here and not some other number. So magic numbers are to be avoided because they require careful review of the context and they expect the reader to fill in the gaps. Thus, numbers are typically the wrong tool for the job in conditionals. Instead, consider setting a well-named constant for use in conditionals. As you can see, the meaning of the number 21 is now crystal clear. There's a second option for eliminating magic numbers, and that is to use an enum. Let's use a different example for talking about enums. Here, we're setting a status equal to 2. Again, it's confusing and completely meaningless without examining the context. But, in the clean version with an enum, it's clear that we're looking for an active status. Now, much like the previous slide, using these constants and enums, instead of magic numbers, helps avoid typos, since the app won't compile if you make a mistake and you'll get Intellisense support from your IDE. Plus, searching for all the usage of a given constant or enum is easy. But the biggest benefit to removing the magic number is it clarifies intent.

Complex Conditionals
All too often, conditionals get out of hand. They tend to grow, over time, until they're hard to work with and unclear. We can see that this conditional is working with certain years of Ford and Chevrolet vehicles that have particular vin numbers but the big question is why? What question is this conditional trying to answer? Before our conditionals grow out of control there are two simple approaches to manage the complexity and clarify intent, so that they don't end up confusing messes like this particular conditional. Number one is intermediate variables, and number two is encapsulation via a function. So let's start by looking at a different example that shows how to implement an intermediate variable. Here's another complex conditional. Now any programmer can read the code, but when you see a conditional, you should ask yourself, what question is this trying to answer? And in this case, it's just unclear. So now let's check out how an intermediate variable helps clear this up. Aha, so now we know that the developer was trying to determine if the employee is eligible for the company pension plan. All through the creation of this simple intermediate variable, we have clarified our intent. Trust me, your readers will thank you. So, we've seen how intermediate variables help clarify conditionals. Now, let's look at a different, more powerful approach. With this conditional, you can see that the author recognized that it was getting complex, and he chose to use a comment to help clarify. However, remember, one of the principles of clean code is to favor expressive code over comments. We should only resort to using comments when the code can't adequately explain itself. So how do we do that? Well we just saw one option is to use an intermediate variable but another approach is to refactor this conditional to a well name method. We can even use the context of the comment to help us name the method well. As you can see the name of the function helps clarify that the intent is to determine if the file request received is valid. Note that the body of the conditional was simply moved inside the function, we just copied and pasted from above down into here. But there's still room for further improvement to fully clarify our intent within the new method that we've created. It's not completely clear why we're making specific checks within this method. So, let's look at a cleaned-up version. Note how we've created a few intermediate variables to further convey our intent. We've made it clear that mpg, mp4 and avi are our list of valid file extensions. It's also now clear that the isAdmin or isActive check is there to determine if the user should be allowed to view the file at all, that was completely unclear up above. Finally, notice that the return line now clearly describes our intent and reads like spoken word. It's a validFileRequest if it's a validFileType and the user is allowed to view the file, very clear. And think about the experience for the reader. If the reader comes across a single line that says, if validFileRequest, all the body of the function can be totally ignored from, by the maintenance programmer if they're fixing a bug that's totally unrelated to this piece. It's a single line that they can skip over and move on. These layers of abstraction really help fellow programmers speed read through our code, so that they can reach the line that they're looking for. Now we could even refactor further, because this method is arguably doing two things. It's validating that the requested file extension is within our list of accepted file extensions and it's also checking if the user has the rights to view the file. Those are two separate pieces of logic that could be re-factored to separate methods, so that each method has a clear single responsibility if desired.

Polymorphism vs Enums
As we saw earlier, enums and constants are useful for conditional logic. However, when logic switching is being used to provide notably different behavior, resorting to switch statements and enums can lead to redundant switch statements and hard to read code. Instead, polymorphism can often provide a more scalable solution. This is particularly true when you notice a switch statement that occurs more than once in your code. Now, in this example, there's different logic that occurs on log in based on a user's status. Imagine there were multiple points throughout the user's class that contained this same switch statement, checking for the user's status and running complex logic based on that user's status. Well, using polymorphism, we can delegate such details to the user class. In this snippet, assume that the user class is an abstract base class that we can see here down below. Let's take a look at how to pull this off. So here's the abstract base class that was passed into the clean example up here above. This defines the structure of our base user object, but since it's abstract, it must be extended to be utilized. So, let's take look at the three specific derived classes that can be called polymorphically to eliminate the switching logic. With this structure, each class knows how to handle itself, so the switch is no longer necessary in multiple places in our code and the logic for each user type is completely encapsulated within these specific classes. Now typically, when you use this approach, you would create a factory and you would have single spot where that switch statement determines, which one of these user objects would get instantiated. But ultimately, the details of how an Active user logs in versus an Inactive user versus a Locked user would all be contained within these specific classes, which really helps you manage complexity within these individual pieces. And it helps eliminate those redundant switches that you could potentially see throughout your code.

Be Declarative
Okay. So, this isn't a slide for everybody. Keep in mind that we're defining a technique as dirty when there's a more elegant and expressive option available. So, if this example isn't an option in your language, do not sweat it. But if your language does support being this declarative, then be a clean coder and put it to use. Now, on to the example, this dirty example reads just fine, but it's the wrong tool for the job in C# since link to objects allows you to be more expressive by declaring what you want rather than writing add hoc procedural code like you see above. This code above is simply looping through a list of users to find those that match some specific criteria. The example on top requires five lines and the manual creation of a looping structure to iterate through all the users. Contrast this with the clean version below using C#'s link to objects. In two lines of very declarative code, we've accomplished the same task. Now let's look back to the point about developers being authors. If we just read aloud what each snippet is doing, the difference is striking. I'm going to read the top first and then I'll read the bottom. So, if I read the top, it says, loop through each user in users and if the AccountBalance is less than the minimum and the user's status is active, add the user to the list of matching users. Then return the list of matching users, that's a mouthful. Let's compare that to the bottom. Return users with an AccountBalance less than the minimum who have an active status. That is simple and expressive and it reads very much like the spoken word, which is a core goal of ours. Now what you're seeing on the left is C#'s link to objects, but there are similar implementations in other languages, like Lambdaj for Java. JLinq for JavaScript or Pynq for Python. So, if your language happens to have this sort of tooling that allows you to be very declarative, put it to use and you'll save yourself some typing and you'll also save your readers from having to read so much code. And then you're also a lot less likely to write a bug, because you're being declarative about what you want rather than writing the code to get you what you want. It has a lot of the same benefits that we have in SQL that we say, to the database here's the data that I want and then the database goes ahead and figures out the query plan to get that for you. You just request the data and the magic happens extracted away from you, so be declarative, if possible.

Table Driven Methods
As developers, we love code. But brace yourself, because the fact is sometimes, code just is not the answer. When? Well, let's look at an example. Imagine we're trying to determine insurance rates based on a customer's age. One way to pull this off is to use a long if statement and place all the rates directly within the code. This is called hard coding. Now hard coding isn't so bad when it's a small amount of data that won't change. But in this case, you can imagine insurance rates will regularly change and thus require changes to our code. You could imagine also how quickly this could spiral into a very complex and dynamic set of logic for a real insurance application. In these instances, the logic typically doesn't belong in the code at all. Instead, it belongs in the database. So here's the data base table that can replace the complex, hard coded if statement on the left. Once the table is populated with the correct data, it's simply a matter of querying the table in your code. It's now a one liner to make a call to get the appropriate rate. We pass at the age and get back the appropriate rate from the table. So not only is our code much cleaner, but any time the data changes, we don't have to release a new version of the application. We simply update a row in the database. Clean code abstracts away things that change and avoids hard coding dynamic values. There's a variety of places that the table-driven approach makes sense, including pricing structures and complex dynamic business rules. This technique can make your applications ultra flexible without requiring much code. And sometimes, it's helpful to think about your logic as nothing more than a complex set of look up data. So, in summary, the table-driven method approach is great for dynamic logic and helps to avoid hard coding data into our application. It also helps us avoid writing and maintaining complex data structures. And finally, it's easily changeable without a coat change or application deployment. A lot of big wins here and a great way to avoid writing code altogether.

Summary
In this module, we learned how to clearly guide our readers when they reach the forks in our code by being clear about our intent. We learn the benefits of being strongly typed by using constants and enums and we avoided being procedural by using declarative tools that allow us to easily specify what we want without having to describe how to get there. Finally, we learned that sometimes code isn't the answer at all and using table-driven methods can eliminate the need for conditionals altogether.

Functions
Intro
Hi, I'm Cory House and in this module on Clean Code we're going to discuss Functions. We're going to learn how to create Functions that have a high signal to noise ratio for easy readability. We'll learn when creating a Function makes sense. And we'll discuss techniques to maintain simplicity in our code. We'll also learn some code smells to avoid and refactoring techniques for eliminating these issues all together. And finally, we'll wrap up by discussing error handling techniques. Now, before we get started a quick piece of business. Throughout this module you'll hear me use the terms Function and Method interchangeably. Understand that both are simply pieces of code that are called by name. The core difference is Methods are associated with an object. So, if you're not into object oriented programming don't worry. The term Method might sound foreign to you, but it's really the same thing for the purposes of this course. The two terms are interchangeable. The principles we'll be discussing apply equally to Methods and Functions. So, let's get rolling.

When to Create A Function
Functions help us organize our code into small targeted pieces of logic. This has many of the same benefits as paragraphs when writing. And much like paragraphs it's much easier to understand what the writer is talking about when the paragraph has a clear purpose and doesn't ramble on about seemingly unrelated topics. Now, there are four common reasons to creat a function. First, to avoid Duplication. Clean Code honors the DRY Principle and doesn't repeat itself. And some developers think this is the only reason to create a function. But, as we're about to see there are a variety of other reasons that functions are useful, even if the code is only called once. Indentation is a sign of complexity. As code gets to deeply Indented it becomes hard to understand and maintain. So, this is another great reason to create a Function. Third reason is that we should remember that understanding the programmer's intent is the hard part. So, we can use well-chosen function names to provide high level summaries of our logic just as headings in a book aid comprehension and navigation. Comments can also serve this purpose, but if you're about to write a comment you can instead create a well-named method that helps convey intent. There's a variety of benefits to this approach that we'll discuss later. Finally, to help maintain a single responsibility methods should do one thing and one thing well. A method that does one thing shouldn't get very long. Remember long paragraphs become tedious too. Now, let's consider each of these reasons to create a function more closely and discuss some techniques to keep our functions clean.

Avoid Duplication
Early on in my career I learned the importance of creating functions when I needed to call the same logic multiple times. I found quickly that copying and pasting code made maintenance harder, especially bug fixes, where I'd have to make sure that I'd changed more than one place. Don't repeat yourself is one of the most important principles in software development since it helps assure that we minimize the lines of code that we have to maintain. Duplicated code means two places to maintain, fix, and two redundant places to read. And as we discussed earlier in the Principles module be sure to look for Patterns. Duplication in our code isn't always obvious. Sometimes you can detect Duplication just by squinting. This code clearly has a redundant shape that infers an opportunity for removing Duplication by refactoring to a single method that takes the necessary parameters. Once you establish the shape it's just a matter of noting the areas that differ. These points are obvious spots for injecting arguments to handle the differences.

Excessive Indentation Overview
The second reason to create a function is Excessive Indentation. As our logic grows more complex it's common to see an arrow shape form. Arrow Code is defined by its arrow shape, which is a reference to the deep levels of Indentation. Arrow Code is a sign that a method has high cyclomatic complexity. This is just a fancy way of saying that there are many distinct paths through a method. High cyclomatic complexity hurts readability, hinders testing, and increases the likelihood of bugs in a given method. So, this arrow shape also hurts comprehension by reducing signal to noise. The reader has to maintain all the layers in his or her head simultaneously. And the negative impact of deep levels of nesting has been documented in studies as well. A 1986 study by Noam Chomsky and Gerald Weinberg found that comprehension decreases beyond three levels of nested 'if' blocks. This excessively nested code is commonly called Arrow Code. There are three simple methods to eliminate this toxic Arrow Code. You can Extract a Method, Fail Fast, and Return Early. Let's walk through each of these.

Extract Method
When refactoring to a method we simply move related pieces of logic to well-named methods that better convey intent and help us eliminate excessively deep indentation. When refactoring Arrow Code its often simplest to start with the most deeply nested code and work your way out. Let's do that by moving this while loop to a method. As you can see, the level of indentation is reduced and the arrow shape is less pronounced. Refactoring to a method has benefits beyond just removing Arrow Code and reducing cyclomatic complexity of the method. It also enhances readability since readers of this method can now skip over a one liner if they're not interested in the details of how this complex section that we just moved works. Now, book authors often do the same sort of thing by moving pieces of data out of the body of the text into figures, tables or appendices. Here is an example from the Wikipedia entry on San Francisco. Notice all the little blue numbers in the article. They're easy to overlook if you're not interested, but they're useful footnotes. If at any point you want to drill down to a specific resource you can click on the link and you get the details. Now, imagine what a noisy mess this article would be with inline footnotes. In this case there's over 200 of them. Refactoring to a method, even when the method is only called once, has much the same benefit of these footnotes that we see here. The method remains available for reference by those interested, but it doesn't add noise when one is simply seeking to understand the big picture. When a class is refactored to many small methods that do one thing well the reader can choose to read at the level of abstraction that is most useful to their purpose. If the reader is looking for a high level overview of the algorithm the top level method signatures provide that and if they want details the child methods are there and their names provide clarity of intent. So, ultimately refactoring to a method offers the same benefits as the footnotes that we see here in this article. The relevant reading is accessible, but it's out of flow for those who aren't currently interested.

Return Early
Returning Early is another helpful approach for eliminating deep indentation in our code. The big idea with Returning Early is if you have nothing more to do return. Let's look at an example. As you can see it's deeply indented. This method is validating a user name. There is a variety of reasons that a user name might be invalid. Note that a local variable is valid is used to store the state of whether the user name is valid and it's defaulted to false at the top of the method. Only if all four of the if statements are evaluated to true is the user name found to be valid. This method has four levels of indentation, which hurts readability. Now, let's review a version that Returns Early. Note, that in this version there's no indentation at all. There's also no need for the temporary isValid variable that was created in the other version. Instead, with each evaluation we check for an attribute that would make the user name invalid and we return as soon as the user name is found to be invalid. This creates a method with multiple return values, which some might find undesirable. Indeed, years ago it was popular logic to only allow one return statement per function. However, Returning Early can really help tame deeply indented code and thus enhance readability and maintainability. Steve McConnell helped emphasize this point in his book Code Complete. He said, Use a return when it enhances readabilityâ€¦In certain routines, once you know the answerâ€¦not returning immediately means that you have to write more code. And that's exactly what we saw in our example. I really agree with Steve's approach here and I believe that Returning Early is also helpful because it mimics real life decision making. Once we know there is no reason to move on we stop.

Fail Fast
Another approach for eliminating excessive indentation is Failing Fast. Failing Fast is really simple to comprehend. When there is nothing more that you can do in a method just Fail. Now, Failing in this case means that you throw an exception as soon as an unexpected situation that can't be handled occurs, as you can see here. These lines are called Guard Clauses. Now, Guard Clauses assure that the inputs to a method are valid before continuing processing. Running all Guard Clauses and Retuning Early simplifies a method by reducing indentation and thus cyclomatic complexity. Guard Clauses are useful for creating a contract at the top of your method that clarifies the expected state for parameters. In this example the user name and password fields are expected to not be null or empty. So, rather than adding levels of nesting that mask the core intent of the method we can place the safety checks at the top of the method and then throw exceptions immediately if an exceptional state is found. If a large number of checks are necessary before performing the body of the method it can even be useful to refactor these checks at the top to a named method. Failing Fast is also useful when working with switch statements. Every switch should have a default value so you're aware when the switch falls into an unexpected state. Consider what would happen in this example if there wasn't a default. If someone attempted to login as a user in an unexpected status the system wouldn't log the user in. But, it also wouldn't have thrown an exception. So, we'd likely get a ticket later from a user complaining about their inability to log in and it would be really difficult to figure out why since the system wouldn't have thrown an error in this spot and it may or may not have failed elsewhere depending on how the related code was structured. This is Failing Slow and it masks root causes and makes debugging a difficult investigative chore. Be sure that you Fail Fast. Also, be sure that you note the unexpected value in the exception so that it's easy to track down later.

Convey Intent
Now, let's consider further the third reason to create a function, to Convey Intent. This is the example that we discussed earlier in the Conditionals module. With this Conditional you can see the author recognized it was getting complex and chose to use a comment to help clarify. However, we can completely clarify our intent in code by refactoring this Conditional to a well-named method with good variable names inside. Note how we've created a few intermediate variables to further convey intent. We've made it clear that mpg, mp4, and avi are the list of valid file extensions. It's also now clear that the isAdmin or isActive check is there to determine if the user should be allowed to view the file at all. And think about the experience for the reader. Now, if the reader comes across a single line that says if (ValidFileRequest) all of the body of the function can be totally ignored if the maintenance programmer is fixing some bug that's totally unrelated to this piece. It's a single line to skip over and move on. These layers of abstraction really help fellow programmers speed read through our code so that they can find the line they're looking for. Now, again we could refactor since this method is really doing two things. It's validating the requested file extension and checking if the user has the rights to view the file. Those separate pieces of logic could each be refactored to separate methods so that each method has a clear single responsibility.

Do One Thing
The fourth and final reason to create a function is to Do one thing. Functions serve much the same purpose as paragraphs in a book. Reading a book with no paragraphs would be a taxing chore as would maintaining a large class with a single method. So, to keep the signal to noise ratio high our function should do one thing. Now, there is a number of advantages to keeping a single responsibility. First, it aids the reader. A well-chosen function name summarizes the functionally inside. It also promotes reuse because small focused functions are easier to reuse than larger functions that do many things. It eases naming and testing. As we learned in the Naming module functions that do one thing are much easier to name and if a function is hard to name or has a name that's too broad that's a sign that there's an opportunity to split it up. Finally, it helps us avoid side-effects. The reader should know what the function does by reading the name. If there's other potentially surprising things going on inside consider refactoring to a separate function.

Mayfly Variables
Can you imagine reading a chapter in a book where a dozen characters were listed upfront. Traditional books introduce readers to new characters when it's time for them to truly interact with the story. Introductions occur just in time. This avoid taxing the reader with a lot of information upfront that's not yet value added and totally out of context. Yet, when I started coding I remember thinking I was being very organized by initializing all of my variables together at the top. Now, the problem with this approach is, it runs directly contrary to the Rule of Seven. The reader has to keep track of all these variables throughout their reading and can't remove them from their finite memory until they go out of scope at the end of the function. Plus, anyone considering refactoring this code now has to consider the implications on the variables above. This adds unnecessary mental weight since any variable in scope must be considered. Developers run the code in their heads as they read. And having an excessive number of variables in scope is like asking our reader to spin multiple plates at once. Instead, well-structured functions should contain only Mayfly Variables. So, what's a Mayfly Variable? Well, the Mayfly has one of the shortest lifespans of any creature on earth. Many only live for 30 minutes and the oldest only live for about 24 hours. We should strive to give our variables Mayfly style lifetimes. There's two simple ways to do this. First, we should Initialize Variables just-in-time. When the variable is needed bring it to life. And the moment that it is no longer necessary get it out of scope so that the mental weight is lifted. Second, if you're creating targeted functions that do one thing you're going to end up with Mayfly variables automatically. Short functions mean variables go in and out of scope in a flash, which makes the readers job less taxing.

Parameters
So, how many parameters is to many? Well, a high number of parameters makes a function hard to follow and it's a strong sign that the function is doing too much. So, we should strive for 0-2 parameters. As you focus on writing small focused functions, hitting this goal will get easier and quite natural. This will make your code easier to read, understand, and test. And it also helps assure that the function is doing one thing. So, take a look at this example. The parameters tell the story quite clear. This function is called SaveUser, but it obviously handles more than that. This function accepts parameters that determine whether it should send an email and what format that email should be in. It lets the caller specify whether it should print. And finally specify whether the user should be send to bill. Emails, printing, and billing are all separate concerns from saving a new user and they souled be handled, therefore, in separate functions. These Boolean parameters area also called Flag Arguments. Flag Arguments are a very strong sign that the function is doing two things since by definition, when a Boolean is true one thing happens, and when a boolean is false a fundamentally different thing happens. Here you can see from the function signature that it both saves and optionally emails a user. These methods can be easily split up so that they have a single targeted responsibility.

What's Too Long?
Too long is a highly arbitrary measurement, but I'm sure you can agree that at some point a function is too long and needs to be split up. Here's a few signs that your function may be getting too long. First, when functions get long developers often resort to using blank lines and comments to separate their lines of thought, much in the same way that authors use paragraphs. However, these blank lines and comments are often a sign that the function is doing too much and could benefit from being split into separate well-named function. Now, to clarify Whitespace and Comments are both useful tools for sure. But, nonetheless they're a smell that a function is getting too long. If it doesn't fit on the screen it might be time to split it up. Now, this is arbitrary, but most functions should fit on your screen, especially at today's high resolutions. This aids reading by providing the reader a full view of an autonomous piece of logic. Keeping functions this short also assures that the reader doesn't have to keep too many variables or pieces of logic in his or her head at once. A function should be easy to name if it has a single clear defined task. So, if you're having a hard time coming up with a name that totally describes what the function does it's likely too long. Refactor it into separate functions. When Multiple Conditionals exist in a function consider calling a separate function to extract out the Conditional. This provides a clear description of the intent given the state of the Conditional. Finally, methods that are hard to digest often work with more than one layer of abstraction at a time. A function should work with a single layer of abstraction. This makes it both easier to read and easier to debug. Also, remember the Rule of Seven again. A function is very hard to digest with seven parameters or more than seven variables in scope at a given time. So, keep an eye out for high numbers of either of these. In his book Clean Code, Bob Martin draws some clear guidelines for functions. He suggests that functions should rarely be over 20 lines and hardly ever over 100 lines. And Functions shouldn't have more than 3 parameters. This used to sound very extreme to me, but I've found that writing small, targeted, well-named methods makes my code easier to write and work with later. I also admire Linux's style guide since they take a very pragmatic take on the subject. They say that the maximum length is inversely proportional to the complexity and indentation level of that function. So, if you have a conceptually simple function that is just one long, but simple case statement it's okay to have a longer function. If you have a complex function adhere to the limits all the more closely. And while I admire this idea I'd like to break it down to a very simple maxim. Simple functions can be longer. Complex functions should be short. Yes, this is arbitrary, but use your best judgement.

Exceptions
In functions things go wrong. And Exceptions are useful for halting the system when it's in a perilous and unexpected state. Let's review three kinds of high level exceptions to help clarify when an exception can truly be ignored. The three types of exceptions we're going to discuss are: Unrecoverable, Recoverable, and Ignorable. Unrecoverable exceptions are by far the most common. Examples include null reference exceptions and file not found exceptions when the missing file makes it impossible for the application to move forward in a useful and predictable state. When Recoverable exceptions occur all isn't necessarily lost. It's worth giving things a second try. Examples of these exceptions are attempting to reestablish a database connection, trying a different file or just waiting for a moment for some third party API to come back up so that you can try again. With Recoverable exceptions it's important to consider ultimately giving up on retries at some point so your application isn't stuck in some infinite loop. But, there's nothing wrong with swallowing an exception in these instances so that you can give it one more try. Finally, there's a rare class of exceptions that's indeed truly Ignorable. I recently wrote a click logging system for use on websites. If the click logging failed I chose to swallow the exception and allow the system to continue normally since it had no impact on the user. We were willing to accept not collecting some data in order to assure the user wasn't impacted when our click logging system failed. There is nothing wrong with logging and ultimately swallowing an exception if you're completely clear on the implications. But remember, these instances are rare and its key to think through the downstream impacts on this system. And by the way, you should never catch an exception you can't handle intelligently, let it bubble up. If you have an error that you can't swallow, that you can't deal with on the spot, and that you can't deal with higher up in the application then your application is broken. The correct behavior for a broken application is to crash immediately. A broken application that tries to limp along in an inconsistent state is a danger to itself, its data, and ultimately its users. The best way to make sure this happens is to throw an unchecked exception. If someone knows how to deal with the error they'll catch it eventually. Otherwise, it'll cause your application, or at least the current use case, to die without causing any further damage or corruption. When considering exceptions keep in mind that logging an error alone isn't enough. In this example, we're registering a speaker in a try block and if it fails we're logging the error. However, after logging the error the system simply moves on to email the speaker. That's a problem. This code block shouldn't allow the application to continue since emailing the speaker a confirmation after a registration failure means that the speaker will be informed that they're registered when they're actually not. Think very carefully about the implications of catching an exception and allowing the system to continue. If the system can't reliably and logically move on, stop processing. To keep try/catch blocks easily readable it's helpful to place the body of the try within a function. Imagine trying to read this version if the commented section were long. It can become hard to see where the try starts and ends. And more importantly, using a function like this clear version provides a clean name for the section of code. This makes it clear to the reader exactly what is being attempted in the try block.

Summary
In this module we learned when it's useful to create a function such as to avoid Duplication, to Convey Intent, to eliminate excessive Indentation, which is also called Arrow Code by Returning Early or Failing Fast via Guard Clauses, and we learned that we need to try to do one thing in each function. We also reviewed many warning signs that a function may be too long including using Whitespace and Comments to organize the code, needing to Scroll to see the whole function, having a problem selecting a Name that fully describes the functions role or simply finding that it's difficult for the reader to digest such as when there are an excessive number of parameters. And we wrapped up with a short discussion on Error Handling. To aid readability call a function in the body of a try so that it's clear what's being attempted. And we learned three fundamental types of exceptions so that we can be cautious about catching and swallowing exceptions, which can create Fail Slow situations that are tricky to debug.

Classes
Intro
This is Clean Code: Writing Code for Humans. I'm Cory House and this module is all about Classes. Now, this course is not specifically focused on Object Oriented Design. That's a large topic all by itself and there's already a great course available on Pluralsight on the SOLID Principles of Object Oriented Design by Steve Smith. Steve also worked with a number of other authors to create an excellent comprehensive course on Design Patterns. These are great followup resources for this course. That said, if you're working in Object Oriented Language well-structured Classes have a huge impact on maintainability and clarity of intent. So, this module covers some simple principles for designing and formatting Classes with the reader in mind. In this module we'll discuss when creating a Class makes sense, the importance of designing cohesive Classes, techniques for organizing the logic and flow of your Classes methods with the reader in mind, we'll learn to watch out for Primitive Obsession in our code, and we'll finish up by discussing the Outline Rule, which will help our readers speed read through our Classes and quickly understand our logic at the desired level of detail. So, let's dive in.

When to Create
Throughout the course we've used the metaphor of thinking like an author to help us write Clean Code. Classes are the heading in this metaphor. A heading in a book provides a high level summary of the content inside. When a reader searches for a specific concept later these heading provide a road map. Headings make a book more scannable and help the reader comprehend the paragraphs inside more easily by providing a high level summary of the topic being discussed. A well-written heading should contain a number of related paragraphs underneath that stick closely to the topic outlined in the heading. Classes are the heading in this metaphor. In the same way well-named and targeted Classes provide a strong que to the high level intent of what's inside and thereby aid the reader. Just like a heading with related paragraphs a Class should contain multiple methods that relate closely to a single clear responsibility. There's a number of logical reasons to create a Class or extract a Class from an existing Class. The first and most obvious reason is to model an object. These objects can model either Concrete or Abstract concepts. Classes are especially helpful with abstract concepts because they assign concrete names and behaviors to these concepts and thereby make them more approachable. This aids the reader and helps us stay organized. If the methods in your Class have little to do with one another it's a sign the Class has Low Cohesion. Classes with Low Cohesion should be split up into separate Classes with more targeted responsibilities. To Promote Reuse. Even if a piece of code could be part of a larger Class put it in its own Class if it is useful for another program and thereby easier to work with. It's also useful to create a Class to reduce complexity. Creating a new Class means that the reader doesn't have to consider the mental weight of a solved problem. The Class hides away the complexity and groups related operations behind the scenes, out of sight, out of mind, and allows somebody to just trust that, that piece will work. Finally, they can be useful to clarify parameters. Classes can greatly simplify information passing when complex data structures are involved. Classes can convert a loose bag of related variables into something more concrete, easier to reason about, and more tangible. If you end up passing the same variables to several functions then quite likely those variables and functions should be a Class. Let's explore a few of these items in more detail.

Cohesion
This is the old Detroit Theater in Detroit, Michigan. As you can see it's now being used as a parking lot. This is highly inefficient and odd, but that's not a surprise because this wasn't ever intended to be the responsibility of a theater. We often run in to the same problems in our Classes when we assign responsibilities to the wrong Class or expect a single Class to do too much. In his book, Structured Analysis and System Specification, Tom DeMarco described the concept of Cohesion. Cohesion is a measure of how strongly the responsibilities of a Class are related. Highly Cohesive Classes have closely related functionality. This makes them easier to read since a Class name serves much the same purpose as a heading in a book. It's easier to understand what a Class is doing when the heading truly summarizes its focus clearly at a high level. Highly Cohesive Classes are more likely to be reused because the logic inside is more likely to be discovered in the first place. When Classes contain large groups of unrelated methods it's far less likely for other developers to even find the code. They are thus more likely to reinvent to wheel and break and DRY Principle by repeating the same logic in their own way in some new Class. Recall that the discussion we had earlier in the Naming Module was about Magnet Classes. Classes with Low Cohesion often have poor names as well since it's difficult to name a Class with many desperate responsibilities. These Classes are often given overly generic names that attract lazy developers who don't want to think about where their logic truly belongs. To avoid attracting lazy developers it's important to keep Class names descriptive. This helps keeps Cohesion high. Now, this principle is closely related to Bob Martins Single Responsibility Principle, which states that each module should do one thing and one thing well and it should have only one reason to change. Now, if you want to learn more about this principle check out Steve Smith's course on Solid Principles, which I mentioned earlier in this module. To avoid creating Low Cohesion Classes keep an eye out for a few things here. First, watch for methods that don't interact with the rest of the Class. In Highly Cohesive Classes the methods and properties work together to accomplish the task. This regular interaction is a sign the Class is Cohesive. Low Cohesion Classes feel more like a random set of functionality, which makes them hard to understand and maintain and less likely to be reused by others. In a similar way watch out for fields that are only used by one method. Fields should be used by many methods in the Class and if they're not consider if the field or set of fields is a sign that the related functionality should be extracted to a separate Class. Source control can also help tell the tale of Classes that are doing too much. If you see a Class that receives many more commits than average it's likely a candidate for refactoring to separate Classes with Higher Cohesion. Let's consider an example of a Class with Low Cohesion. This Vehicle Class allows you to edit vehicle options, update pricing, schedule maintenance, send maintenance reminders, select financing, and calculate monthly payments. Now, these items are all generally related to vehicles. A Class handling these rather desperate responsibilities though is likely to have Low Cohesion because the methods that deal with maintenance will utilize a very different set a fields than the vehicle options and financing and payments will require complex math and business logic that is totally unrelated to the simple tasks of editing vehicle options. So, let's look a potential refactoring. So, this refactoring of the Vehicle Class breaks it into three separate Classes. These Classes are more Cohesive since they perform a closely related set of functions. The Vehicle Class now handles the responsibilities that are very specific to the core vehicle data like editing vehicle options and pricing. The Vehicle Maintenance Class handles scheduling maintenance for vehicles and sends maintenance related reminders. The Vehicle Finance Class handles presenting financing options and calculating monthly payments based on the selected financing options. Imagine I need to add a new feature for financing a vehicle. By placing the financing logic in a separate Class I now have an obvious and more approachable Class to review and modify. I've also reduced the risk because my change to the Vehicle Finance Class should be highly unlikely to impact any functionality in the Vehicle Maintenance or Vehicle Classes. Also, keep in mind that the Cohesion becomes increasingly important as a Class grows larger and logic within the application becomes more complex. In a very small simple system mixing these concerns together in a single Class wouldn't necessarily feel burdensome. But, imagine if each of these Highly Cohesive Classes on the right contained a thousand lines of code. Then, the idea of being placed together would sound extremely painful. You likely recognize the examples in this slide from the Naming Module. But, with Classes names are so critical for assuring High Cohesion that this merits discussing again. Classes with overly general and undescriptive names lead to Magnet Classes and as we know magnets attract items. In the same way Classes with poor names, like these, attract lazy developers. Classes with names like Common and Utility often grow quickly to thousands of lines of unrelated code. When you instantiate a Class you should have a clear idea of what it is and what it does just from the name. This is why Classes should typically have noun names. The more concise the name the smaller the Class. So, start with naming well and strive for Class Cohesion. You can roughly measure Class Cohesion by reviewing how many methods use the Classes instance variables. Instance variables used by only one or two methods are an indication that those methods could be refactored out to another Class.

When is A Class too Small?
Developers often complain about code. But, how many times can you recall complaining that a Class you were reading was too small? Ya, it's certainly possible to make this mistake, sure. But, it's a real rarity. Developers nearly always error on the side of creating Classes with too many desperate pieces of functionality. That said, here's a few signs that a Class is too small. If two Classes rely heavily on one another and call a large portion of each other's methods, then they might be a candidate for joining into a single Class. Closely related to this, if you see one Class that relies heavily on another Class then this feature envy might be a sign that the two Classes belong together. Finally, overly small Classes can make it difficult to understand how the system hangs together. There's just too many small moving parts. This can lead to other issues like Classes that are tightly bound to one another. But, be forewarned. These issues are all nearly unicorns in the real world. Developers rarely make this mistake of overly small Classes and very often make the mistake of creating monolithic Classes with way too many responsibilities.

Primitive Obsession
Object oriented programmers can easily slip into passing around loose pieces of related data that should really be encapsulated within a Class. This Dirty example breaks the Rule of Seven by having more than seven parameters. These parameters are all clearly properties of a user so a user object should be passed into this method instead. Now, there's a tradeoff to be made here. If the method used only one or two parameters from a user then passing the specific necessary properties can help clarify the precise data dependencies and the methods intent by showcasing what is required without viewing the method body. The Clean version lumps related data items into a Class. There are multiple benefits to this approach. It helps the reader conceptualize the code and intent by assigning a well understood name to the group of parameters. It takes something implicit, in this case a long list of parameters, and makes it explicit by assigning the group a name that can be reasoned about. Properties can encapsulate business logic and rules for their values to avoid putting in ad hock code wherever these primitives are utilized. If another property is later added to the user object that needs to be leveraged by this method, the method signature itself isn't impacted. And finally, you can easily find all references to the user object in code. When you pass around a loose set of primitives finding all the references to those primitives in the related user data can become a daunting task. So remember, if you're passing around a set of related data items it's a sign that it's time to create a Class.

Principle of Proximity
Readers naturally read from the top down. Thus, it's really helpful to keep related actions together. It's very natural to be reading a method and see it call another method. So, if the callee is the next method below the reader's job is very easy. It's harder to read and work with a Class when you have to scroll up and down or use a keyboard shortcut to jump back and forth while reading function calls. This Class snippet is laid out top down. Notice how when you read the call to validate data you can glance down and see that it's the next method in the Class. The next call within ValidateRegistration is SpeakerMeetsOurRequirements. You'll notice again that it's placed right below ValidateData. So, it's still conveniently close. Now, this is of course a loose rule since methods are often called multiple times from different places and you can only place a function in one spot. But, when possible it's helpful to the reader to keep methods that interact or that are closely related to one another close to each other in the Class.

Outline Rule
A well-written outline has multiple layers. It defines high level concepts and drills down to specific points made under each concept. Or think about a well-written book. If you're thumbing through an unfamiliar chapter looking for a specific high level idea it's helpful to have section headings. Then you can easily scan for a particular high level concept. Classes that utilize the Outline Rule offer the reader the same benefit. See, the Outline Rule increases the signal to noise of our code by providing the reader with multiple layers of abstraction. These layers are provided by creating well-named methods that describe the high level steps involved in a process. Each of these high level methods delegate to lower level methods that ultimately do the work. With this style you may have some methods that are literally nothing but a list of related method calls and that is okay. It converts something implicit and potentially confusing into a well-named structure that's easier to understand and better conveys intent. By doing so you build an Outline into your code allowing the readers to reason about your code at the layer of abstraction that's most helpful to their purpose. Often, Classes contain one or two high level methods that drill down into Child Methods. With a structure like this a high level overview of the algorithm involved isn't clearly provided. Consider this cleaner example instead. You can see a high level overview of the three methods involved. If you want an overview of what Method 1 is doing you can review the names of its three Child Methods. If the functionality outlined in Method 1a is of interest you can even see that at a high level it involves the steps outlined in 1ai and 1aii. When a Class is designed to honor the Outline Rule it's easy to review its functionality and the layer of abstraction that is most useful to your purposes and dig down to the right level of detail as needed. Now, this is a tricky concept to get right at first. In the next module our demo will walk through implementing the Outline Rule in an example application.

Summary
In this module we learned the importance of writing Highly Cohesive Classes. Classes should contain strongly related methods. We learned that we should keep an eye out for Primitive Obsession. Don't pass around related sets of data. Instead create a Class to that it's a first Class citizen that's easier to understand and work with. To keep your readers from having to scroll up and down constantly to read and understand your Class strive to organize your code to read top down where possible and place related pieces of code together. Finally, when designing complex Classes create multiple layers of abstraction using the Outline Rule so that the code reads like a high level outline. This will allow readers to view your code at the level of detail that's most useful for their purpose and quickly find the section that they're looking for.

Comments
Introduction
Hi, I'm Cory House. In this module we'll be discussing the role Comments play in writing Clean Code. So, when I ask interviewees what Clean Code is to them they almost always mention Comments. And Comments indeed have their place. But, heres the thing. Overreliance on Comments is a Code Smell. And if this is all you can say about the topic of Clean Code that's not a great sign. Comments should only be chosen as a solution after a consideration of the alternatives. Like any other data structure there should be a clear reason to justify their existence. Comments are either Signal or Noise. So, let's walk through some examples. There's no shortage of opinion on the topic of Comments. It sure gets these girls fired up. Now, Sally has some good points. Comments are sometimes not kept up to date and they can be used to explain confusing code that could simply be refactored in a cleaner manner. But, Julie has an important point too. Many developers think their code is clean enough that it doesn't need comments, but as we've seen throughout the course, clearly conveying intent is not easy. So, you're probably looking for a definitive answer to the bottom line question. Are comments great, or a code smell? Well, I'm going to answer that definitively. Yes. Yes they are. How's that for a programmer answer? It returns true. As we'll see Comments are both.

Necessity and Crutch
So, as we'll see throughout this module Comments are both a Necessity and a Crutch. Let's review a couple rules that will help guide our conversation. First, prefer expressive code over comments. Comments are useful, but when code could do the same job with equal clarity we should choose to make our intent clear in code instead of comments. Why? Well, code is more likely to be kept updated by maintenance programmers and is, of course, the definitive reference for what the code is doing. Second, we should use comments when the code alone can't be sufficient for providing the necessary documentation. Let's dive in and review some specific examples. Here's a list of comments that we should try to avoid. Let's go ahead and walk through these one by one.

Redundant
At the top of our list are Redundant Comments. Redundant Comments repeat exactly what the code says right next door. So, there's really no value added here and we'll look at some examples. Here I am setting i to 1. That is completely clear in the code on the left. I am instantiating a new user. Or I am marking my Default Constructor, which is obviously clear if the name of the method matches the name of the class in C# for instance. Finally, I'm calculating total charges. Here I've repeated the exact name of my method up in my comment. Now, the problem with Redundant Comments is they break the DRY Principle. You are repeating yourself. You've now created two different points that you have to maintain and you've really added no value. This is also lowering the signal to noise ratio. This is extra text that the reader is typically going to read, but they're not getting any value from it as there is no new content here. So, you'll often see these when people require comments on every single method and especially down here, this CalculateTotalCharges for instance, it's not really necessary to add a comment on every single method if your methods are named well and in this case it is so there's no additional fidelity that comes from this particular comment so you might as well just remove it and free up a few lines on your screen. So, in summary here's two rules to avoid Redundant Comments. First, assume that your reader can read code in the language that you have written. Second, don't repeat yourself. The code itself conveys all the information that you need for these simple examples. No comments are necessary.

Intent
Throughout the course we've discussed the merits of conveying your intent in code where possible. In this example, the developer is using a comment to clarify what the magic number 2 stands for. This is easily refactored out via a well-named constant, or in this case, an enumeration. Now, the code clearly conveys intent. No comment necessary. Now, there's a number of ways to avoid needing to create an Intent Comment including creating an improved function name, declaring an intermediate variable, creating a constant or an enumeration as we saw above or finally, refactoring a conditional into a well-named function.

Apologies and Warnings
Ah, Apology Comments. These are the comments that make maintenance programmers want to cry. You finally navigated to the point where the bug was reported and just to find a comment like this. Comments like this are a sign that the original developer just didn't bother finishing the job. It's malpractice because it leaves a mess for someone else to have to clean up later. Here's another example. This developer was so exhausted after merely getting it to work that the left a mess that no one else has hopes of easily understanding. Keep in mind no one likes apologizing so why not just avoid it. Instead, fix the issue before you commit or merge your code. Or if for some reason that's not possible add a TODO marker comment if you must. We'll talk about TODO comments shortly. Warning Comments are closely related to the Apology Comments we just discussed. But, they are arguably even worse. Why? Well, they are also warning that lousy code is ahead, but with Warning Comments the developer isn't bothering to apologize. Warming Comments are often characterized by a warning that a section of code can only be touched by a certain developer. Sometimes warning are indeed necessary, but in many cases they are simply a sign of an area that needs to be refactored.

Zombie Code
Say you're house sitting. You walk in the living room and you see this. Imagine your inner dialog. It's a nice house, but that's ugly and odd. I need to turn on the light, but what's with the tape? And what would happen if I remove this tape and turn it on? Perhaps you decide to call the owner. Oh, I put a ceiling fan in, but it wobbles and crashes to the floor when I turn it on. I'll fix it at some point. Ya, sure you will. Until then this bizarre tape switch remains. We don't except half-baked features on our homes so why should we do so in the code that we support. So, what does this odd behavior look like in code? Well, it looks like this. Imagine your reading through code trying to fix a bug or add a feature. What do you do when you come to sections of commented out code? It totally disrupts your flow. These sections of commented out code are Zombie Code. Why Zombie Code? Well, zombies aren't really dead. As horror movies have taught us those zombies appear to be dead. They're still alive enough to haunt us. In the same way Zombie Code straddles this line between alive and dead just waiting for a chance to ruin our day. Commented out code is alive because it's in the current code base. Programmers stumble across it in a keyword search and interact with it during maintenance and refactoring. But, the code is also dead because it's not executed in production. Thus, it's a Zombie that should be buried pronto. Today's code never really dies. As long as you have source control there's always a historical reference that will get you back to previous versions. I propose that there are two root causes for the ongoing problem of Zombie Code. The first is Risk Aversion. Some developers view deleting code as inherently risky. They lack the strength of conviction and sense of purpose that's required to delete unnecessary code so they hoard it in comments where it can live to haunt another day. Sure, it's easier to not even think about whether code should remain in the code base, but code must be deleted regularly because great developers know that code is a liability. Less is more. And yes, keep in mind commented out code is still code, but its code that's not solving any problems. It's just getting in the way. Second, there's a problem with a Hoarding mentality. Developers may argue that they comment out code just in case it might be useful to someone later. This is Hoarding and does us all a disservice. Code that is no longer useful for production remains in source control history. Remember with source control, deleted code doesn't die it's merely buried alive. Commenting out code just creates noise for the reader and saddles our application with technical debit. Commented out code is just as useless to the application as this old trash is to this kitchen. The old wrappers and labels tell a story of what we used to do in the kitchen, but at the expense of us getting anything new done efficiently. As we've discussed throughout the course when writing code we must strive to keep our Signal to Noise Ratio as high as possible. This aids in comprehension, speeds reading, and helps protect us from creating buggy code due to misunderstanding. Zombie Code is directly opposed to comprehension. It slows reading and maintenance because less actual production code is on the screen at any given time. It's visual noise because it's unclear if one should read it at all. For some reason we often accept this compromise as developers, but we'd never accept such sloppiness in the real world. Imagine if the New York Times looked like this. We would not stand for this. Notice how reading the text doesn't flow? The increased noise hurts comprehension. And it's difficult to ignore the commented section even though it's likely irrelevant or worse, misleading and incorrect. Now, one could argue that source code isn't the finished product. So, a comparison to a finished publication is apples and oranges. Okay. But, we must remember that every line of code written will be read an average of 10 times. So, yes our readership is smaller than the Times, but it's an important readership with a loyal following. It's us. Zombie Code makes the story unclear. Should a programmer spend time reading the commented out code or not? Commented out code also creates Ambiguity about whether the code should have been commented out at all. Imaging you're a maintenance programmer who stumbles across a swath of Zombie Code around an area where a bug has been reported. The programmer's job is now much harder. The commented code must be read and comprehended to determine its potential impact. Was the code accidentally commented out for testing and never averted? Perhaps the person who commented out can help. So, who was that? An investigation ensues. This additional Ambiguity takes time to resolve and adds mental weight to what could otherwise be a simple debugging process. This Ambiguity also hinders refactoring. Remember that we should regularly be leaving the code a little better than we found it. But, when a class or a method contains a chunk of Zombie Code things get tricky. If I refactor this section do I need to consider this commented out code? Will it be turned back on again soon? How will it interact with my new implementation? These are questions maintenance programmers shouldn't have to ask. Furthermore, integrated refactoring tools won't make corresponding changes to commented out code. Thus, as methods, variables, and classes are renamed and signature are changed the commented out code falls behind. When commented out code is resurrected it's highly likely the app won't even compile. So, in summary Zombie Code is a problem because it reduces the readability of our code. It creates ambiguity because we need to wonder whether the commented out code should have ever been commented out in the first place. Perhaps it's the very reason that the bug is occurring. This also hinders refactoring because we have to consider whether the commented out code needs to be refactored when we're changing other code around it. It also adds noise to searches. When we're doing keyword searches Zombie Code shows up and it really should no longer be in scope. Finally, code isn't "lost" anyway. Remember, with source control we can always get back in time to see previous versions of the code. So, here's a mental checklist. If you're about to comment out code ask yourself: When if ever, would this code be uncommented? If there's not a definitive impending date then it's likely it never will be uncommented. Can I delete this and simply get it from source control later if necessary? Is this incomplete work that should be rolled back and worked via a branch instead? This avoids adding noise and confusion for others. Is this a feature that should be enabled or disabled via configuration? If you're commenting out code to temporarily disable a feature perhaps a configuration setting would be more appropriate. Finally, did I refactor out the need for this code all together? If it's no longer necessary just delete it.

Dividers and Brace Trackers
If you've ever maintained a code base burdened with extremely long functions then you've likely seen this trick. When functions get too long developers often resort to using comments to break up sections as you can see here. If your function has gotten so long that it's getting hard to navigate consider refactoring to a few separate functions to enhance readability and remove the need for the Divider Comment all together. Much like the Divider Comments we just discussed Brace Tracker Comments are used to help developer navigate really long stretches of code. So, here's the idea behind Brace Tracker Comments. When the body of a conditional grows long enough that we can't fit it all on the screen then when you see a closing curly brace it can be really unclear what it's closing. So, these Brace Tracker Comments sit here at the end of the conditional and tell us what it's closing. Now, this sounds like a friendly idea, but there's a better alternative. Just like Divider Comments it's easily avoidable by refactoring to a function. This separate function will enhance readability and it also reduces the cyclomatic complexity of the function.

Bloated Header
Hey, check out my flashy Bloated Header. Back when I was working regularly in the Unix Shell we required a similar boiler plate template at the top of every file. The idea was to enforce consistency and make sure we had all the info we needed if a bug popped up. But, there is a number of issues with this particular example. First, avoid line endings on comments like this. Keeping those asterisks at the right place is really a hassle. Enough so that some developers may decide not to update the header at all to avoid it. Second, don't repeat yourself. The file name is completely obvious by viewing the file itself and the author and the created date should be accessible via source control instead. Finally, rather than creating your own ad hock style for comments follow your languages style Conventions.

Defect Log
Okay, you do use source control right? Well, if you don't I highly recommend it. Hopefully you do and if so then you can avoid using comments like this for logging defect fixes in your code. Change metadata belongs in source control, not code. Adding comments like this to code can quickly make reading a really noisy chore. Imagine how annoying it would be to read a book filled with all the author's notes about where they fixed logical fallacies and typos. It would make following their story much more difficult. Defect Log comments cause these same issues.

Clean Comments
Alright, enough with the negativity. Now, let's walk through some examples of Clean Comments. Don't you wish you had more time to make your code base better? Well, in the real world we often have to settle for making a note of something that we'd like to do at a later time. To Do Comments are handy because they allow the developer to easily get back to a specific section of code that needs more attention later. Now, I hesitate to call To Do Comments clean since they can certainly be abused. But, they're useful enough that Visual Studio even provides a dedicated task list window where you can see any comments that begin with To Do, Hack or Undone. Here's a few tips for assuring To Do style comments remain useful. First, if your IDE Of choice doesn't offer this support make sure you Standardize as a team so that everyone understands the intent of these comments. Second, watch out for many To Do's that are actually an apology or a warning in disguise. If there is time to do it right now finish it, because the fact is these are very often just ignored. I've seen many code bases littered with To Do's from well-meaning programmers who have never gotten around to working through their task list. But, when used judiciously To Do Comments can be a handy way to keep track of open items that need attention in the short term. Summary Comments offer much the same benefit to readers as an introduction at the beginning of a book. They prepare the reader for what to expect. Good Summary Comments describe the code at a high level that's not necessarily apparent by simply reviewing the class or the functions name. They're often particularly useful for providing a high level overview of classes since a class name alone isn't typically sufficient to fully convey the scope and interactions of the methods inside. However, be sure you're not using Summary Comments to augment poorly named classes or functions. Small well-named functions are often so self-documenting that a Summary Comment would simply be redundant. So, seek to convey your intent in code. But, be sure to add Summary Comments to give your readers the high level context that they need. Sometimes we have important data to track that just isn't possible to convey in code. In these cases comments can help us provide documentation directly within the code where it's most likely to be useful. Documentation comments such as these are often helpful when interacting with third parties.

Summary
In summary, for Clean Coders comments are indeed useful. But, they should only be used after carefully considering the alternatives. Here's a few questions that you might ask yourself before creating a comment. First, could I express what I'm about to type in *code* rather than via a comment? There's a lot of tools at our disposal like intermediate variables, the elimination of magic numbers or perhaps utilizing an enumeration. We could also consider refactoring to a well-named method, which has a number of benefits like separate scope and being more likely to staying updated and better testability. Second question is, am I explaining bad code that I've written instead of just refactoring it? If there's an opportunity to make it better and clearer than make the code more expressive and that's a benefit for everybody regardless of whether the comments are read and maintained. Finally, should this simply be a message in a source control commit? Source control stores the history of our application. If you're just commenting out code be sure to remember the implications of creating Zombie Code. Consider just deleting it instead.

Demo
Introduction
Hi, this is Clean Code: Writing Code for Humans. I'm Cory House and in this module it's all going to come together. We're going to refactor an example application using many of the principles that we've been discussing throughout this course. In this module we're going to hit the beach. We'll walk through an example application that handles speaker registration for a fictitious developers conference called Code Luau. We're going to put the principles that we've discussed throughout the course to use to improve the quality of our code and we'll review some specific Metrics that can be useful for evaluating the cleanliness of our code base. We'll use this Metrics to compare the quality of our code before and after our refactoring exercise. So, I'm ready to hit the beach. Let's dive in. I love going to development conferences. And if I was going to organize my own I'd put in Hawaii and call it Code Luau. This example application is a speaker application form for my fictitious developer's conference. So, I'm going to fill it out. (Typing) And as I do this data is going to be useful for determining whether I'll be accepted to this conference. And we'll just throw in some data here for certifications. And ultimately my session is going to be, well I guess it's going to be about fish. Clean Cod or Cleaning Fish for Humans. How about that. That's an oddity, but that'll work so we'll hit Submit. And then you can see, okay, based on the information that I put in I've been accepted to Code Luau. Now, if I had put in some different information I might have gotten a different message here saying that I hadn't been accepted because we're running logic behind the scenes to determine whether somebody will get accepted to this conference. Let's review the Business Logic that takes place behind the scenes. We begin by Validating the Data entered and if it's not valid then we Throw an Exception. Then we review the speakers data to see if they Appear Exceptional. If they do then we look at their Session data and if it's approved then we Approve the Speaker. If they didn't appear exceptional we check for any Red Flags that might mean they might not be a good fit for this conference. Then we end up reviewing their Sessions again and Approving the Speaker if their sessions are approved. Let's take a look at the project. The application is broken down into three traditional Layers. The Presentation Layer handles the user interface. The Business Layer contains the business logic and also has a separate project that contains Tests, which we'll talk about in a moment. And finally, we have a Data Access Layer that handles the persistence concerns by interacting with the database. The Presentation Layer is using ASP. NET MVC and some jQuery. Let's take a look at the controller that we were just hitting when we made our request. So, we'll open the Speaker Application Controller. And as we can see here this Index Method is called when we make our initial request. And this method down here is called when we post the form back. Now, there's not too much to see here. The Speaker Business Object is hydrated with data that we were posting from our form and then ultimately we add in the certifications and sessions into the Speaker Class. And finally, we make a call to register the speaker. Let's take a look at the Speaker Class because that's going to be the focus of our work today. (Typing) So, the Speaker Class sits within the Business Layer and here it is. As you can see these are the properties that correspond to the data that we entered on the Speaker Application Form. And down here we have the Register Method. Now, one of the first things I like to do in a class that I'm not familiar with is collapse everything so I can just see the Method Signatures. Now, in this case you can see this is not that big of a class, it's only 200 lines, but you can also see that other than this little section for custom exceptions it has a single method called Register. This method starts at line 30 and ends at line 181. So, it's a pretty good size method. Some might not think that that's very long, but as we're going to see there's a lot of room for improvement within this method.

Registration Overview
Now, since this Register Method is going to be the focus of our work let's just scroll through it and get a high level feel for what it takes care of. You can see that it initializes some variables at the top and then checks whether required data is provided. Then, it moves on and sets a list of employers I assume, yes based on this comment that's clear. And then something called good and it looks through some email domains and ultimately if something is good we are going to look through our sessions and work with some technologies and potentially throw an exception if sessions weren't passed in with the speaker. If we get this far it looks like we end up calculating registration fees and ultimately saving the speaker to the database. Then, the method closes by throwing exceptions if expected data isn't provided. And finally returns the speaker ID to the caller. Alright, so let's get back to the Register Method. Now, as we saw earlier this code is deeply indented. Let's count the level of indentation. Here's our first, second, third, fourth, five levels deep, here we become six levels deep, seven, eight, eight levels deep and perhaps it looks like eight is about as far as we go. But, remember the Rule of Seven where we said it's very difficult to maintain more than seven items in memory at once. This method is a real strain to read because the reader has to maintain a lot of different pieces of complexity in their head at once. And remember also that our goal was to avoid more than three levels of indentation because studies have shown that more than three levels of indentation hurt comprehension.

Code Metrics
Visual Studio provides Code Metrics that allow us to evaluate the quality of our code. To run Code Metrics just right-click on the project and select Calculate Code Metrics. Now, you'll see the information pop up across the bottom of our screen. What we're focused on is the Register Method. As we can see the Register Method has a Maintainability Index of only 35. Now, this is on a scale of 0-100 so 35 is a low number. The Cyclomatic Complexity of our method is 34. Now remember, that's just a fancy word for the number of distinct paths through the code. 34 different paths is a lot of complexity in a single method. We can also see that we have a high level of Coupling in our Register Method. 13 different classes are being called by our Register Method. And finally, this is an oddity. While we saw on the left by looking at the line numbers that there was about 150 lines of code within the Register Method. In actuality, there's only 53 lines of code. So, this is a strong sign that there's just room for improvement on formatting the code so that it doesn't take up so much of the screen at once. There's a lot of unnecessary comments and whitespace within this code.

Automated Tests
Before we begin refactoring it's important to note that grading tests to assure that you don't cause regressions is an important first step. Automated Testing is a large topic on its own and it's not the focus of this course. But thankfully, as you can see here, we already have a test suite for this class. And there's a large number of methods within here that makes sure the business logic is operating as expected. Now, we can Run these tests and when we do we can see that all of our tests pass. We get the nice green check boxes. So, we're starting off with a clean slate and as we begin refactoring we can regularly rerun these tests and make sure that we haven't caused regressions in our code.

Comments
Now, as we learned in the Comments Module they can be very useful to assist the reader with understanding the code especially with high level summaries. However, this method has a variety of comments that are just creating noise. Let's start by removing some comments that are reducing the signal to noise ratio of this method and they're making it more difficult to read since they are just unnecessary. Beginning right here at the top lets init some variables. We can see that variables are being initialized below. So, we'll nix this. Here we have what appears to be just a piece of Zombie Code. Remember Zombie Code is a problem because it hinders our refactoring and makes the code harder to read. Do we need to consider this? Is this a feature that someone plans to turn back on soon? Is it an old feature that should have been deleted? With Zombie Code like this you have to research to get answers to your questions. Let's assume that we've conducted our research and confirmed that this is an old feature that we've decided to never make live. Thus, we can safely delete this line as well. This is a source control comment. Remember, your source control system should be the system of record for storing the history of your code. With source control there is no need to litter our code with references to who changed a line and the related ticket number. So, let's just assume that I've checked the source control system and found that a corresponding comment was added when this line was changed. Thus, we can delete this comment as well. Below here we have another comment that really looks like it should have been in source control. So, we will assume that it was and remove it as well. And we'll scroll down through. It looks like another example like this, we weren't requiring a session. And now we are. This looks like another piece of Zombie Code that was probably related to the array that we deleted earlier. So, we can remove this code as well. (Typing) And we'll leave this one for now to help us understand what's going on here. And we'll address these other comments as they come up, as we move through the rest of the code.

Mayfly Variables
Let's move back to the top of the method. The Register Method begins by registering a large number of variables at the top. This is not ideal because when writing code we should strive to create mayfly variables. Remember mayflies have ultra-short lifetimes and our variables should have short lifetimes as well. To minimize the variable lifetime these variables should be initialized just in time and removed from the scope as soon as possible. That said, the fact that so many variables are involved in this one method is also a sign that it's doing more than one thing. So, as we'll see below there are many opportunities to refactor this logic into separate well-named methods. But for now, let's just move these variables down as far as we can so that they are initialized as close as possible to their first use. Visual Studio makes it easy to find the first usage of a given variable. Just click on the variable name and you'll see the other usages highlighted in gray. So, we can see that we could initialize good down here. So, I'll just go ahead and do so and then we can remove line 33. The new line 33, appr, is a poorly named variable, but what it's really getting at is whether the speaker has been approved so I'll go ahead and rename that to approved. Now, let's see how far down we can move approved. It looks like we could get right over here to line 63 and that'll get us a lot closer to the first usage. So, let's pull this and we'll pop it in here. Are there any others that we can move? Okay, we have ot, another poorly named variable. In this case what this is really about is oldTopics in technology so let's go ahead and rename it. And then what's the first usage of oldTopics? Way down here. Okay, and it looks like that's the only place that it's used as well. So, let's pull oldTopics all the way down to here. Have we gotten rid of everything at the top? SpeakerID is going to have to stay for now since it needs to stay all the way out here in this scope. And the final variable that we can move is domains. This is a list of domains. And let's find the first place it's used. Not until down here in this complex conditional. So, we'll pop it in just above. And now as we can see other than speakerID, which as I said needs to stay here for now until we do some other refactoring, we've cleaned up all of these other variables so that they're now mayfly variables, they have the shortest lifetime that they can. And that'll help us continue our refactoring.

Guard Clause
So, now the method begins by checking for whether valid data exists on these lines. Now, these are called Guard Clauses. They are making sure that the valid data is available before we go on and do our work. However, by formatting it this way it greatly increases our indentation and hurts readability because the corresponding else is way down here. I have to scroll a long way to get it and it's difficult to find which one of these corresponds with the check up above. So, what we can do instead is scroll back up here and refactor all of these into a single method that handles all of our Guard Clauses. And let's see what that looks like. So, what we'll do is remove these checks from the body of this method and we'll come down here to the bottom and remove the corresponding checks for first name, last name, and email. (Typing) And this does mean that all of this will now need selected and moved way over because it's not going to be nearly as indented as it was before. Now, it appears that we may have one extra curly brace still in here. We should be good now, there we go. Alright, and the method that we will create will be called ValidateData. So, now we've moved all our validations, these are all Guard Clauses that now sit within a well-named method. And we can call this method right up here at the top. Because we really know that if we don't have valid data there's no point in moving on. So, we will validate our data first. Now, the beauty of moving that over into a separate method is we've already greatly reduced the level of indentation in this method. If we zoom back we can see that the Arrow Code shape that we saw before is a lot less pronounced.

Naming Issues
Often the hardest part about reading and refactoring code is determining the programmer's intent. Poorly named variables and methods are a great place to start to improve our readability. And now that we have moved the variables that were formally initialized at the top next to their first usage it should help us determine their purpose. Here's a list called emps. It appears to be a list of employers. This is where the reader has to be a bit of a software archeologist. What is this list of emps for? We can see that it's used in a conditional right below called good, which is also poorly named. Ultimately we can see that if good is true the logic continues and a speaker may be approved to speak. Thus, after some further reading it appears that what we really have here is a list of preferred employers. Let's rename the list as such. (Typing) And since the comment above was merely a crutch for the poorly named variable we can now remove it as well. And remove the unnecessary whitespace below.

Returning Early
The variable good is being set via a very complex conditional. There's a lot going on here so we'd do well to rename some of these variables to better convey intent. Exp is a property that's storing the years experience that was entered on the registration form. (Typing) So, let's rename it. And it appears what we're really trying to figure out here is if the speaker appears qualified based on the information that they entered. So, let's rename good to speaker appears qualified. (Typing) And note also that this is honoring the naming principles that we discussed on Booleans. SpeakerAppearsQualifed is obviously a question that would return either true of false. Now, we can see after looking at this a bit further that SpeakerAppearsQualified is getting set in a few different places. That its true if one of these evaluates to true, which are basically we're looking for good things about a speaker, like whether they have a blog or a lot of certifications or years experience. So, these are really the signs that somebody appears to be exceptional. And then if they don't appear to be exceptional based on these things we come down here and look for any red flags, any indications that they might not be somebody that we'd want to speak at our conference. So, it might help to create two different methods here that better convey the intent of what's going on. So, let's take the body of this conditional right here and move it to a well-named method that we will call AppearsExceptional. (Typing) And we'll put this in down below. (Typing) Now, what we can do here, instead of having a single long conditional, we can return early on each of these so it reads a little bit more like real life. So, we would consider you exceptional if you have over 10 years experience. And we would do so like this. We would say, if YearsExperience is greater than 10 return true. (Typing) And if HasBlog return true. Or if your CertificationCount is greater than 3 return true. Because any one of these things can be true. Or if PreferredEmployers. ContainsEmployer, ah, so see how we have a problem here. We've got to go take that preferred employer list that was defined up here at the top and pull it on down. Now given, this reformatting that I've made below, I'll put these on separate line, this is really stylistic. I'm not a fan of long conditionals, especially those that end up with three or four or five different or signs or and operators within them. So, this is my preference to return early. It reads more like an interview. Imagine that I was having a conversation with you, it will need to return true here. And then ultimately we will return false if none of those were true. And if I was interviewing a potential speaker I would say, do you have over 10 years experience? If someone said yes then I would just return true. I wouldn't even ask them these other questions because I already established that they appear exceptional based on our business logic, which says that just one of these items needs to return true.

Refactor Red Flags
So, now scrolling back to the top we can see that SpeakerAppearsQualified is getting set in one other place. Down here it is set to true if these items evaluate properly. So, what's really happening in this area is we're looking for a few red flags. These are a few things that we don't want to see in our speakers, but we don't check these in all cases. We only check these if somebody doesn't appear exceptional. So, our real logic is the speaker appears qualified to us if they appear exceptional or they have no obvious red flags. That really describes what this logic is doing below. So, what we can do is take all of this and move it to this new method called ObviousRedFlags. So, I'm just going to hit F12 to bounce down there and paste this in. Okay, so what we need to do is ultimately we will return (typing) right here true if the items above, we'll have to change this around to be opposite, so we're saying you have obvious red flags if you have an email domain that's in this list. Or you have what we're defining as an undesirable browser, which in this case in an old version of Internet Explorer. Those are some signs that you might not be the type of speaker that we're looking for, for this conference. Again we have an opportunity to rename a variable. In this case it's a list of email domains, but it's not just a list of domains, these are ancient email domains. (Typing) And now we understand that we are looking for either ancient email domains or someone who has an old version of Internet Explorer and saying that's a red flag in our case. So, we will return false otherwise. Or in fact we can simplify this further and just say return whatever this conditional evaluates to. So, we're saying return true if someone has an ancient email or has an old version of Internet Explorer. Now, at this point it's a judgement call. Have we refactored enough? This method really does more than one thing still. The obvious red flags method splits an email domain and then it looks for whether that list of ancient email domains contains the speaker's email domain and it ends up checking for someone's browser as well. And we are missing a semicolon on the end. So, we could refactor this further, but in this case I'll just let you make your own decision. I won't walk you through that piece.

Consolidate Guards and Clarify Intent
So, let's collapse some code and take a look at our progress. We now have a few separate methods that are well-named. And our Register Method has gone down in size and is now about 100 lines instead, which is a big improvement. We've gotten rid of about 50 lines out of it. Now, we can also remove this since we just refactored out the need and it's all handled here within a single line. And now the beauty of this is, you can understand the intent very clearly. We are saying that a speaker appears qualified if they appear exceptional or if they don't appear exceptional then we check to make sure that there's no obvious red flags. That's the way that our business logic reads. Remember back on previous slides where we outlined our intent. This conveys that same intent that we were showing within that logic flow. And now we can see that we're moving on to the approval of the sessions that the user has submitted. We can see that we check whether any sessions were submitted and otherwise down here will throw an exception if no sessions were present. Now, this is really an odd thing to be doing this late in the game. This is the sort of thing that we could have checked right up front within our ValidateData Method. So, let's just go ahead and do that. I'm going to take this exception and move it down here to ValidateData. Because this is another thing that's just required. It should be a Guard Clause that occurs immediately. And what I need to get is this check and pull it down to here. So, if Sessions. Count equals 0 then we will throw an exception that at least one session needs to be present, otherwise there's nothing for us to do in this method. Alright, so we'll scroll back up and this again will get rid of some our indentation. We'll get rid of this curly brace and we'll get rid of the else as well. And then we have just a little bit of a formatting cleanup to do. I think we have one more curly brace hanging here. Let me make sure that we, yep, it looks like were all set here. I'm going to collapse these other methods and also just nix some whitespace here. Alright, so now what we're doing is looping through sessions and it looks like what we're looking for is old topics and making sure that somebody isn't trying to speak on really old topics like Punch Cards and Commodore 64s, which are interesting, it's just not the focus of my fictitious conference. Now, ultimately we can see that the goal here is to either approve or deny a session based on whether it is about an old topic. So, let's refactor this foreach into its own method. So, we'll right-click, we'll say Extract Method, and in this case we'll call it ApproveSessions. Because that's really what's going on there. We're going through the list of sessions and approving them. Now, there's still room for improvement to better convey intent. What we're really doing here is checking whether the session is about old technology. So, instead let's just create a new method called SessionIsAboutOldTechnology. And ultimately what we'll do is loop through each of the sessions and say, okay the session will be approved if the session is not about old technology. And I'll need to pass it the session. Now, we have this method currently returning a Boolean when it goes to ApproveSessions basically to say whether any sessions were approved. Because up above here we were checking whether at least one session was approved and if not we were throwing an exception. So, really this exception can now sit within the ApproveSessions Method. And right here what we'll do is say, okay no sessions were approved if the count of approved sessions is 0. And this is where we can use link to objects in C# to do this declaratively on a single line. This is the right tool for the job. And if no sessions were approved then we can throw a NoSessionsApproved exception. And it looks like we'll just need to put in a message. (Typing) And we'll also want to change the return type here because it no longer needs to return any information. It just rolls through and approves sessions and if none are approved it will throw an exception. So, we can go ahead and collapse these now and come back to the top and instead we will just make a call to ApproveSessions and we don't need this check anymore because the exception would have been thrown in ApproveSessions if at least one session weren't approved. So now, we can reduce the indentation again, remove the extra curly brace, and we've almost removed all the indentation within the Register Method. It is down to around 50 lines of code.

Table Driven Method and Fail Fast
So, now we come across a list of if/else statements. These statements are calculating the registration fee to attend the conference as a speaker. Yes, even as a speaker you have to pay at this conference. It's nice. But, if you have over 10 years experience you get in for free. So, that's the way our logic is set up. However, this is the wrong tool for the job. We shouldn't be hardcoding in these values. Let's put them somewhere where they'd be more flexible. Now, I'm not going to go through the motions of showing you how to put it into the database. We'll just assume that now when you save a speaker part of SaveSpeaker calculates the registration fee. So, I'll just pull this out and we no longer need the comment either because it's going to be clear what's going on here. You can imagine that if we went into SaveSpeaker we'd see this other logic there. Now, here we have a problem with the code failing slow. You can see that they're catching all exceptions in case a database call fails. Now the problem is, if this failed then that would mean that the speaker would think that they had been registered when they actually hadn't been. The exception would be swallowed and they'd still get a message on the end saying thank you. So, let's just remove this. We should allow the application to fail. If the database were down for some reason that's okay, there's nothing that we can do about it, we'll just let the exception bubble up.

Outline Rule
During our refactoring we eliminated the need for another variable. This one called Approved, so that no longer needs to be passed into ApproveSessions because it wasn't ever utilized within here. So, we'll remove it as well. And now we can see that the Register Method has become a lot easier to work with. It's small enough that it fits on our screen and we can absorb it all. There is still some further room for improvement to finish this up. We do a lot of checks, such as validating the data, validating whether the speaker appears qualified, and then we can drill down into different layers to see what that means and then ultimately approving their sessions and saving the speaker. But really this, this, and this are all something that we could wrap up within a validation type of method. So, let's create a new method called ValidateRegistration. So, here's our new method called ValidateRegistration and we can see that we validate data so we no longer need ValidateData up here. We check if the speaker appears qualified and if they are not then we throw the exception. So, that exception no longer needs to be thrown up here in the Register Method and this check for whether the speaker appears qualified doesn't happen either. We also don't need this if statement anymore. We just need to call ValidateRegistration right up here. (Typing) And then we can also remove this curly brace and now we've removed all indentation from the Register Method. Op, I'm sorry, this is also part of validating registration so that would go away. So, here's the cool thing, this now reads like an outline. We validate someone's registration, which contains the steps down here below and if it all validates then we go ahead and save the speaker and get a speaker ID back and then we return that speaker. That's it. The Register Method now starts at 30 and ends at 40. It's 10 lines. Nice and small, easy to understand, and we can always drill down into these different layers because we are honoring the Outline Rule. Now, this code is by no means perfect. It relies heavily on throwing exceptions in order to fail fast. And many would argue returning status codes instead would be a preferable approach. Some of the methods still do more than one thing. And there are hard coded values that should be removed. Finally, there's opportunities to extract some logic out to separate classes such as the session approval logic, however, I'm sure you agree this is a vast improvement in readability and really helps pull together a lot of the principles that we've discussed throughout this course.

Regression Test
Alright, so it looks like we're done with our refactoring lets go ahead and run our test and make sure that we haven't caused any regressions in our code with these changes. We run the test and look at the, ah-oh, we've got red x's so we have created a regression in our code. We've got to go hunt this down. Let's see what we can find. (Typing) Okay, I think I see the problem here. We are looking for whether a speaker appears qualified and it looks like we're throwing an exception when we shouldn't. This needs a negation because our real intent here is if the speaker is not qualified then we want to throw an exception. So, this would most certainly have introduced a behavioral change within our code. Let's go ahead and rebuild again. And then we'll rerun our tests (typing) and check the explorer. Op, we're down to two, but we're still not all the way there. So, we can see that the test that's failing is related to the checks for red flags, the browsers, and ancient email so I'm guessing that the place that's causing problems is going to be in here in the obvious red flag section. Now, okay I see the problem. Our logic should be that someone has red flags if either of these are true. That either they have an ancient email address or they're running an old version of Internet Explorer, but I had two ampersands in her instead of two pipes. So, let's Save again. And Build and we will rerun our tests. (Typing) And there we go that's the green we're looking for. So, it looks like we're all set now.

Bug Fixes: What a contrast!
Now just imagine that you're bug hunting with this new structure. In the old setup you had a single method that you had to sift through and hold a lot of information in your head and you really had to read it all to understand it and make sure you didn't introduce a bug. In the new structure you can jump into the right method by just looking at the high level summary that's provided by all these different method names and well-named intermediate variables. So, the person fixing a bug is much more likely to be able to quickly jump to the right section of the code. So, the great thing about our refactoring is we've now created a lot of small methods that do one thing. They honor the TED Principle. Terse, Expressive, and Do one thing. So, let's hit Ctl-MO. The great thing is now we have an outline of some different high level things that we do. Imagine that you're a maintenance programmer and you've been told that there's a bug in the way that we're improving sessions. Well, what you'd do here is probably glance through the method names and go, Oh well here's one called ApproveSessions, this is probably where it sits. I'd come in here and go, Oh alright it looks like we're looking at old technologies, yes because someone had said that we're not filtering out all the old technologies so let's go look at this. I'd go, Ah okay now I've found the list and its definitive and easy to understand. I can feel very safe that I've found the right piece of code to change. Think about the old structure and how tricky that would have been. Or imagine someone wants to know later, Hey what do we consider to be an exceptional speaker for this conference? Well, if you looked through this class it'd be pretty easy to find out. Oh here we go, here's a method that stores all of that data and we can see really easily a summary of the four specific items that we look for to determine whether somebody appears exceptional. In the end the Outline Rule gives us these layers of abstraction that we can easily dig through and find what we're looking for. It allows us to speed read through this class and easily maintain and fix bugs.

Code Metric Results and Conclusions
Let's see how our code analytics compare now that we've finished our refactoring. We'll go back to the Business Layer and Calculate Code Metrics and when we do we look at the Register Method. Ah, now the Maintainability Index has increased to 75. That's a big improvement. The Cyclomatic Complexity is now 1, which means there's a single path through that one method. We can also see now that the Class Coupling is down to only 2 and there's only 5 lines of code compared to the 150 that we had before and we could also spend some time looking through our other methods where we refactored out and we can see that they all have pretty good numbers as well. There's still some room for improvement in some of these, but you can imagine where you go. Now keep in mind, the principles that we've discussed in this course are useful, but like any techniques you can take them too far. We could have continued refactoring to the point that every single line is a method call that describes exactly what we're trying to do there. There's a balance that you have to come to here and I feel like what we've described here is a pretty good middle of the road. We haven't gone too far to the point where every single line is a method call describing our intent. But we have provided a good amount of expressive code to make it clear to the maintenance programmer what we're trying to do. Okay, so this class still has opportunities for improvement. We could continue by refactoring the session related logic over to the Sessions Class for instance. But, this is a vast improvement in the three core tenets of Clean Code. It's now using the right tool consistently. This was a problem with us hardcoding in the calculations for registration charges for instance. It has a much higher signal to noise ratio. By removing the comments, the unnecessary whitespace, by improving the naming of the variables, by refactoring to well-named methods we've elevated the signal to noise. And ultimately we've created self-documenting code. You can come in here and understand the intent and what the code should be doing just by reading it. In this module we learned why refactoring is important and established some prerequisites such as creating good tests. And hey, those tests turned out to be really useful since I introduced a few regressions along the way. We converted a long run-on method into multiple well-named methods. And we made our intent clear in code and thereby removed the need for many comments. We honored the TED Principle by being Terse, Expressive, and Doing one thing. This increased the signal to noise ratio, which made the code easier for readers to understand and maintain. And we ultimately reduced the Cyclomatic Complexity of our code, which will help improve readability and ease of maintenance down the road.

Stay Clean
When to Refactor
Hi, I'm Cory House and in this final module of Clean Code: Writing Code for Humans we're going to discuss Getting and Staying Clean. We'll review some simple guidelines for when to refactor existing code using Clean Code Principles, as well as techniques for keeping our code clean. Once you've started enjoying the benefits of Clean Code Principles in the code that you write you'll be tempted to use these same techniques to refactor existing code. But, I like to remember the principle of if it isn't broke don't fix it. There's nothing wrong with improving your code base, but before you do so remember three simple rules. If you're refactoring code it should be code you're currently working with. Refactoring for future readers is of questionable values since it means your means investing time now for readers that may not materialize in the future. If code is hard to read, but exists in a system that's been chugging along reliably for years don't risk changing it merely in a desire for cleanliness. Refactoring is useful when you find the code difficult to comprehend or change. I emphasize the word you here because this is truly subjective. If you're fixing a simple bug and find the code clear enough, fix the bug and move on. Excessive refactoring of old code is of questionable value when the size of your change is small. Generally, the size of your refactoring should be in line with the size of the code change that you are making. If you need to make a simple one line change, refactoring multiple methods is likely excessive. Finally, before making any changes be sure you have sufficient test coverage to assure your changes don't introduce regressions in the code.

Broken Windows
How many times have you worked on a poorly written and maintained code base where developers have given up taking pride in their work? This depressing situation doesn't happen overnight. It's the byproduct of many small hacks and compromises that were accepted and overlooked over the years. Consider a story from the March 1982 issue of the Atlantic. A building with a few broken windows that aren't repaired has the tendency for vandals to break in and break more windows. Eventually, they may even break into the building and if it's unoccupied, perhaps become squatters or light fires inside. Once people can see that a building has been disrespected it's much more likely for others to treat it in the same manner. This toxic mindset affects software projects as well. To maintain Clean Code bases and avoid costly ground up rewrites we need to maintain pride in our code bases and not allow the mistakes of our past to open the door for accepting evermore technical debt.

Code Reviews & Pair Programming
In both commercial and residential construction building inspectors regularly review work to assure that crews are maintaining a high level of quality and following established policies. This arrangement is equally useful in software development. Code Reviews are a highly effective way to avoid the broken windows mentality that we just discussed. Regularly reminding developers that their code will be peer reviewed promotes higher code quality. And setting clear guidelines assures that everyone is clear about the expectations and what is on and off limits for a Code Review. Code Reviews assure readability since reviewers must be able to read and comprehend the code to understand it and review it. This is a time consuming process, but just like building inspections the time and cost help protect from the risk of costly problems later. Consider working in pairs. Pair Programming offers many of the same benefits as Code Reviews, but in real-time. And pairing increases code quality because developers working together are less likely to take costly and confusing shortcuts when writing code. Pairing also makes naming and refactoring easier as you have someone else to bounce your ideas off of in real time. There's a variety of other benefits to Pair Programming, but the benefits to code quality alone are enough to justify giving it a shot.

Boy Scout Rule
The Boy Scouts have a rule that you should leave the campground a little better than you found it. Robert C. Martin reminds us that we should have this same goal when working with existing code. If we continually leave our code a little better than we found it then code bases won't need big scary rewrites. They will stay clean.

Conclusion
In this short wrap-up module we were reminded not to go wild and start refactoring any code we see that isn't clean. We should only refactor when necessary and this means it should be code that we currently need to work with and the magnitude of our refactoring should be comparable to the size of the necessary code changes. Setting and maintaining coding standards will help keep our code clean and watching for broken windows during these code reviews will help assure that the quality of our application continues to be respected. And if you haven't already, give Pair Programming a try using these techniques. You'll likely find it's easier to design your application, select good names, and clarify your intent with a partner. And you're both more likely to strive for clarity in your code by spurring each other on. Finally, remember the Boy Scout Rule, when your editing existing code strive to leave it a little better than you found it. If we consistently do so then we're far less likely to have to rewrite an application later. So, that's a wrap on this course. I really hope the principles and techniques that we've discussed will increase your enjoyment of programming by elevating your code quality. I'm wishing you many lines of Clean Code. Thanks for watching.